import * as __farm_external_module_node_buffer from "node:buffer";import * as __farm_external_module_node_child_process from "node:child_process";import * as __farm_external_module_node_fs from "node:fs";import * as __farm_external_module_node_os from "node:os";import * as __farm_external_module_node_path from "node:path";import * as __farm_external_module_node_process from "node:process";import * as __farm_external_module_node_timers_promises from "node:timers/promises";import * as __farm_external_module_node_url from "node:url";import * as __farm_external_module_node_util from "node:util";(globalThis || window || global)['897f3a29e35d6dec0be3b29e442ddaba'].__farm_module_system__.setExternalModules({"node:buffer": __farm_external_module_node_buffer && __farm_external_module_node_buffer.default && !__farm_external_module_node_buffer.__esModule ? {...__farm_external_module_node_buffer,__esModule:true} : {...__farm_external_module_node_buffer},"node:child_process": __farm_external_module_node_child_process && __farm_external_module_node_child_process.default && !__farm_external_module_node_child_process.__esModule ? {...__farm_external_module_node_child_process,__esModule:true} : {...__farm_external_module_node_child_process},"node:fs": __farm_external_module_node_fs && __farm_external_module_node_fs.default && !__farm_external_module_node_fs.__esModule ? {...__farm_external_module_node_fs,__esModule:true} : {...__farm_external_module_node_fs},"node:os": __farm_external_module_node_os && __farm_external_module_node_os.default && !__farm_external_module_node_os.__esModule ? {...__farm_external_module_node_os,__esModule:true} : {...__farm_external_module_node_os},"node:path": __farm_external_module_node_path && __farm_external_module_node_path.default && !__farm_external_module_node_path.__esModule ? {...__farm_external_module_node_path,__esModule:true} : {...__farm_external_module_node_path},"node:process": __farm_external_module_node_process && __farm_external_module_node_process.default && !__farm_external_module_node_process.__esModule ? {...__farm_external_module_node_process,__esModule:true} : {...__farm_external_module_node_process},"node:timers/promises": __farm_external_module_node_timers_promises && __farm_external_module_node_timers_promises.default && !__farm_external_module_node_timers_promises.__esModule ? {...__farm_external_module_node_timers_promises,__esModule:true} : {...__farm_external_module_node_timers_promises},"node:url": __farm_external_module_node_url && __farm_external_module_node_url.default && !__farm_external_module_node_url.__esModule ? {...__farm_external_module_node_url,__esModule:true} : {...__farm_external_module_node_url},"node:util": __farm_external_module_node_util && __farm_external_module_node_util.default && !__farm_external_module_node_util.__esModule ? {...__farm_external_module_node_util,__esModule:true} : {...__farm_external_module_node_util}});(function(_){for(var r in _){_[r].__farm_resource_pot__='plugin_178e.js';(globalThis || window || global)['897f3a29e35d6dec0be3b29e442ddaba'].__farm_module_system__.register(r,_[r])}})({"07218eb7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "makeError", ()=>makeError);
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_human_signals = farmRequire("63f59b29");
    const getErrorPrefix = ({ timedOut, timeout, errorCode, signal, signalDescription, exitCode, isCanceled })=>{
        if (timedOut) {
            return `timed out after ${timeout} milliseconds`;
        }
        if (isCanceled) {
            return 'was canceled';
        }
        if (errorCode !== undefined) {
            return `failed with ${errorCode}`;
        }
        if (signal !== undefined) {
            return `was killed with ${signal} (${signalDescription})`;
        }
        if (exitCode !== undefined) {
            return `failed with exit code ${exitCode}`;
        }
        return 'failed';
    };
    var makeError = ({ stdout, stderr, all, error, signal, exitCode, command, escapedCommand, timedOut, isCanceled, killed, parsed: { options: { timeout, cwd = module.f(_f_node_process).cwd() } } })=>{
        exitCode = exitCode === null ? undefined : exitCode;
        signal = signal === null ? undefined : signal;
        const signalDescription = signal === undefined ? undefined : _f_human_signals.signalsByName[signal].description;
        const errorCode = error && error.code;
        const prefix = getErrorPrefix({
            timedOut,
            timeout,
            errorCode,
            signal,
            signalDescription,
            exitCode,
            isCanceled
        });
        const execaMessage = `Command ${prefix}: ${command}`;
        const isError = Object.prototype.toString.call(error) === '[object Error]';
        const shortMessage = isError ? `${execaMessage}\n${error.message}` : execaMessage;
        const message = [
            shortMessage,
            stderr,
            stdout
        ].filter(Boolean).join('\n');
        if (isError) {
            error.originalMessage = error.message;
            error.message = message;
        } else {
            error = new Error(message);
        }
        error.shortMessage = shortMessage;
        error.command = command;
        error.escapedCommand = escapedCommand;
        error.exitCode = exitCode;
        error.signal = signal;
        error.signalDescription = signalDescription;
        error.stdout = stdout;
        error.stderr = stderr;
        error.cwd = cwd;
        if (all !== undefined) {
            error.all = all;
        }
        if ('bufferedData' in error) {
            delete error.bufferedData;
        }
        error.failed = true;
        error.timedOut = Boolean(timedOut);
        error.isCanceled = isCanceled;
        error.killed = killed && !timedOut;
        return error;
    };
}
,
"0db3db94":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_mimic_fn = module.i(farmRequire("19589191"));
    const calledFunctions = new WeakMap();
    const onetime = (function_, options = {})=>{
        if (typeof function_ !== 'function') {
            throw new TypeError('Expected a function');
        }
        let returnValue;
        let callCount = 0;
        const functionName = function_.displayName || function_.name || '<anonymous>';
        const onetime = function(...arguments_) {
            calledFunctions.set(onetime, ++callCount);
            if (callCount === 1) {
                returnValue = function_.apply(this, arguments_);
                function_ = null;
            } else if (options.throw === true) {
                throw new Error(`Function \`${functionName}\` can only be called once`);
            }
            return returnValue;
        };
        module.f(_f_mimic_fn)(onetime, function_);
        calledFunctions.set(onetime, callCount);
        return onetime;
    };
    onetime.callCount = (function_)=>{
        if (!calledFunctions.has(function_)) {
            throw new Error(`The given function \`${function_.name}\` is not wrapped by the \`onetime\` package`);
        }
        return calledFunctions.get(function_);
    };
    exports.default = onetime;
}
,
"128b79b8":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getStreamAsBuffer", ()=>getStreamAsBuffer);
    var _f_array_buffer = farmRequire("abb2baa0");
    async function getStreamAsBuffer(stream, options) {
        if (!('Buffer' in globalThis)) {
            throw new Error('getStreamAsBuffer() is only supported in Node.js');
        }
        try {
            return arrayBufferToNodeBuffer(await _f_array_buffer.getStreamAsArrayBuffer(stream, options));
        } catch (error) {
            if (error.bufferedData !== undefined) {
                error.bufferedData = arrayBufferToNodeBuffer(error.bufferedData);
            }
            throw error;
        }
    }
    const arrayBufferToNodeBuffer = (arrayBuffer)=>globalThis.Buffer.from(arrayBuffer);
}
,
"1464d5a7":function  (module, exports, farmRequire, farmDynamicRequire) {
    let _fs;
    try {
        _fs = farmRequire("ffc819a8", true);
    } catch (_) {
        _fs = globalThis.nodeRequire('fs', true);
    }
    const universalify = farmRequire("712c2dd4", true);
    const { stringify, stripBom } = farmRequire("22ca6445", true);
    async function _readFile(file, options = {}) {
        if (typeof options === 'string') {
            options = {
                encoding: options
            };
        }
        const fs = options.fs || _fs;
        const shouldThrow = 'throws' in options ? options.throws : true;
        let data = await universalify.fromCallback(fs.readFile)(file, options);
        data = stripBom(data);
        let obj;
        try {
            obj = JSON.parse(data, options ? options.reviver : null);
        } catch (err) {
            if (shouldThrow) {
                err.message = `${file}: ${err.message}`;
                throw err;
            } else {
                return null;
            }
        }
        return obj;
    }
    const readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
        if (typeof options === 'string') {
            options = {
                encoding: options
            };
        }
        const fs = options.fs || _fs;
        const shouldThrow = 'throws' in options ? options.throws : true;
        try {
            let content = fs.readFileSync(file, options);
            content = stripBom(content);
            return JSON.parse(content, options.reviver);
        } catch (err) {
            if (shouldThrow) {
                err.message = `${file}: ${err.message}`;
                throw err;
            } else {
                return null;
            }
        }
    }
    async function _writeFile(file, obj, options = {}) {
        const fs = options.fs || _fs;
        const str = stringify(obj, options);
        await universalify.fromCallback(fs.writeFile)(file, str, options);
    }
    const writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
        const fs = options.fs || _fs;
        const str = stringify(obj, options);
        return fs.writeFileSync(file, str, options);
    }
    const jsonfile = {
        readFile,
        readFileSync,
        writeFile,
        writeFileSync
    };
    module.exports = jsonfile;
}
,
"14cbc7d0":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>stripFinalNewline);
    function stripFinalNewline(input) {
        const LF = typeof input === 'string' ? '\n' : '\n'.charCodeAt();
        const CR = typeof input === 'string' ? '\r' : '\r'.charCodeAt();
        if (input[input.length - 1] === LF) {
            input = input.slice(0, -1);
        }
        if (input[input.length - 1] === CR) {
            input = input.slice(0, -1);
        }
        return input;
    }
}
,
"14fd5962":function  (module, exports, farmRequire, farmDynamicRequire) {
    var fs = globalThis.nodeRequire('fs', true);
    var core;
    if (process.platform === 'win32' || global.TESTING_WINDOWS) {
        core = farmRequire("49576d3a", true);
    } else {
        core = farmRequire("c9805378", true);
    }
    module.exports = isexe;
    isexe.sync = sync;
    function isexe(path, options, cb) {
        if (typeof options === 'function') {
            cb = options;
            options = {};
        }
        if (!cb) {
            if (typeof Promise !== 'function') {
                throw new TypeError('callback not provided');
            }
            return new Promise(function(resolve, reject) {
                isexe(path, options || {}, function(er, is) {
                    if (er) {
                        reject(er);
                    } else {
                        resolve(is);
                    }
                });
            });
        }
        core(path, options || {}, function(er, is) {
            if (er) {
                if (er.code === 'EACCES' || options && options.ignoreErrors) {
                    er = null;
                    is = false;
                }
            }
            cb(er, is);
        });
    }
    function sync(path, options) {
        try {
            return core.sync(path, options || {});
        } catch (er) {
            if (options && options.ignoreErrors || er.code === 'EACCES') {
                return false;
            } else {
                throw er;
            }
        }
    }
}
,
"153226a7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getRealtimeSignals", ()=>getRealtimeSignals);
    module.o(exports, "SIGRTMAX", ()=>SIGRTMAX);
    var getRealtimeSignals = ()=>{
        const length = SIGRTMAX - SIGRTMIN + 1;
        return Array.from({
            length
        }, getRealtimeSignal);
    };
    const getRealtimeSignal = (value, index)=>({
            name: `SIGRT${index + 1}`,
            number: SIGRTMIN + index,
            action: "terminate",
            description: "Application-specific signal (realtime)",
            standard: "posix"
        });
    const SIGRTMIN = 34;
    var SIGRTMAX = 64;
}
,
"187e10b8":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getSignals", ()=>getSignals);
    var _f_node_os = farmRequire("node:os");
    var _f_core = farmRequire("5ea68443");
    var _f_realtime = farmRequire("153226a7");
    var getSignals = ()=>{
        const realtimeSignals = _f_realtime.getRealtimeSignals();
        const signals = [
            ..._f_core.SIGNALS,
            ...realtimeSignals
        ].map(normalizeSignal);
        return signals;
    };
    const normalizeSignal = ({ name, number: defaultNumber, description, action, forced = false, standard })=>{
        const { signals: { [name]: constantSignal } } = _f_node_os.constants;
        const supported = constantSignal !== undefined;
        const number = supported ? constantSignal : defaultNumber;
        return {
            name,
            number,
            description,
            supported,
            action,
            forced,
            standard
        };
    };
}
,
"19589191":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>mimicFunction);
    const copyProperty = (to, from, property, ignoreNonConfigurable)=>{
        if (property === 'length' || property === 'prototype') {
            return;
        }
        if (property === 'arguments' || property === 'caller') {
            return;
        }
        const toDescriptor = Object.getOwnPropertyDescriptor(to, property);
        const fromDescriptor = Object.getOwnPropertyDescriptor(from, property);
        if (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {
            return;
        }
        Object.defineProperty(to, property, fromDescriptor);
    };
    const canCopyProperty = function(toDescriptor, fromDescriptor) {
        return toDescriptor === undefined || toDescriptor.configurable || toDescriptor.writable === fromDescriptor.writable && toDescriptor.enumerable === fromDescriptor.enumerable && toDescriptor.configurable === fromDescriptor.configurable && (toDescriptor.writable || toDescriptor.value === fromDescriptor.value);
    };
    const changePrototype = (to, from)=>{
        const fromPrototype = Object.getPrototypeOf(from);
        if (fromPrototype === Object.getPrototypeOf(to)) {
            return;
        }
        Object.setPrototypeOf(to, fromPrototype);
    };
    const wrappedToString = (withName, fromBody)=>`/* Wrapped ${withName}*/\n${fromBody}`;
    const toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');
    const toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');
    const changeToString = (to, from, name)=>{
        const withName = name === '' ? '' : `with ${name.trim()}() `;
        const newToString = wrappedToString.bind(null, withName, from.toString());
        Object.defineProperty(newToString, 'name', toStringName);
        Object.defineProperty(to, 'toString', {
            ...toStringDescriptor,
            value: newToString
        });
    };
    function mimicFunction(to, from, { ignoreNonConfigurable = false } = {}) {
        const { name } = to;
        for (const property of Reflect.ownKeys(from)){
            copyProperty(to, from, property, ignoreNonConfigurable);
        }
        changePrototype(to, from);
        changeToString(to, from, name);
        return to;
    }
}
,
"1aaeac37":function  (module, exports, farmRequire, farmDynamicRequire) {
    var constants = globalThis.nodeRequire('constants', true);
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
        if (!cwd) cwd = origCwd.call(process);
        return cwd;
    };
    try {
        process.cwd();
    } catch (er) {}
    if (typeof process.chdir === 'function') {
        var chdir = process.chdir;
        process.chdir = function(d) {
            cwd = null;
            chdir.call(process, d);
        };
        if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
    }
    module.exports = patch;
    function patch(fs) {
        if (constants.hasOwnProperty('O_SYMLINK') && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
            patchLchmod(fs);
        }
        if (!fs.lutimes) {
            patchLutimes(fs);
        }
        fs.chown = chownFix(fs.chown);
        fs.fchown = chownFix(fs.fchown);
        fs.lchown = chownFix(fs.lchown);
        fs.chmod = chmodFix(fs.chmod);
        fs.fchmod = chmodFix(fs.fchmod);
        fs.lchmod = chmodFix(fs.lchmod);
        fs.chownSync = chownFixSync(fs.chownSync);
        fs.fchownSync = chownFixSync(fs.fchownSync);
        fs.lchownSync = chownFixSync(fs.lchownSync);
        fs.chmodSync = chmodFixSync(fs.chmodSync);
        fs.fchmodSync = chmodFixSync(fs.fchmodSync);
        fs.lchmodSync = chmodFixSync(fs.lchmodSync);
        fs.stat = statFix(fs.stat);
        fs.fstat = statFix(fs.fstat);
        fs.lstat = statFix(fs.lstat);
        fs.statSync = statFixSync(fs.statSync);
        fs.fstatSync = statFixSync(fs.fstatSync);
        fs.lstatSync = statFixSync(fs.lstatSync);
        if (fs.chmod && !fs.lchmod) {
            fs.lchmod = function(path, mode, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lchmodSync = function() {};
        }
        if (fs.chown && !fs.lchown) {
            fs.lchown = function(path, uid, gid, cb) {
                if (cb) process.nextTick(cb);
            };
            fs.lchownSync = function() {};
        }
        if (platform === "win32") {
            fs.rename = typeof fs.rename !== 'function' ? fs.rename : function(fs$rename) {
                function rename(from, to, cb) {
                    var start = Date.now();
                    var backoff = 0;
                    fs$rename(from, to, function CB(er) {
                        if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 60000) {
                            setTimeout(function() {
                                fs.stat(to, function(stater, st) {
                                    if (stater && stater.code === "ENOENT") fs$rename(from, to, CB);
                                    else cb(er);
                                });
                            }, backoff);
                            if (backoff < 100) backoff += 10;
                            return;
                        }
                        if (cb) cb(er);
                    });
                }
                if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename);
                return rename;
            }(fs.rename);
        }
        fs.read = typeof fs.read !== 'function' ? fs.read : function(fs$read) {
            function read(fd, buffer, offset, length, position, callback_) {
                var callback;
                if (callback_ && typeof callback_ === 'function') {
                    var eagCounter = 0;
                    callback = function(er, _, __) {
                        if (er && er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            return fs$read.call(fs, fd, buffer, offset, length, position, callback);
                        }
                        callback_.apply(this, arguments);
                    };
                }
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
            }
            if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
            return read;
        }(fs.read);
        fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync : function(fs$readSync) {
            return function(fd, buffer, offset, length, position) {
                var eagCounter = 0;
                while(true){
                    try {
                        return fs$readSync.call(fs, fd, buffer, offset, length, position);
                    } catch (er) {
                        if (er.code === 'EAGAIN' && eagCounter < 10) {
                            eagCounter++;
                            continue;
                        }
                        throw er;
                    }
                }
            };
        }(fs.readSync);
        function patchLchmod(fs) {
            fs.lchmod = function(path, mode, callback) {
                fs.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
                    if (err) {
                        if (callback) callback(err);
                        return;
                    }
                    fs.fchmod(fd, mode, function(err) {
                        fs.close(fd, function(err2) {
                            if (callback) callback(err || err2);
                        });
                    });
                });
            };
            fs.lchmodSync = function(path, mode) {
                var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
                var threw = true;
                var ret;
                try {
                    ret = fs.fchmodSync(fd, mode);
                    threw = false;
                } finally{
                    if (threw) {
                        try {
                            fs.closeSync(fd);
                        } catch (er) {}
                    } else {
                        fs.closeSync(fd);
                    }
                }
                return ret;
            };
        }
        function patchLutimes(fs) {
            if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
                fs.lutimes = function(path, at, mt, cb) {
                    fs.open(path, constants.O_SYMLINK, function(er, fd) {
                        if (er) {
                            if (cb) cb(er);
                            return;
                        }
                        fs.futimes(fd, at, mt, function(er) {
                            fs.close(fd, function(er2) {
                                if (cb) cb(er || er2);
                            });
                        });
                    });
                };
                fs.lutimesSync = function(path, at, mt) {
                    var fd = fs.openSync(path, constants.O_SYMLINK);
                    var ret;
                    var threw = true;
                    try {
                        ret = fs.futimesSync(fd, at, mt);
                        threw = false;
                    } finally{
                        if (threw) {
                            try {
                                fs.closeSync(fd);
                            } catch (er) {}
                        } else {
                            fs.closeSync(fd);
                        }
                    }
                    return ret;
                };
            } else if (fs.futimes) {
                fs.lutimes = function(_a, _b, _c, cb) {
                    if (cb) process.nextTick(cb);
                };
                fs.lutimesSync = function() {};
            }
        }
        function chmodFix(orig) {
            if (!orig) return orig;
            return function(target, mode, cb) {
                return orig.call(fs, target, mode, function(er) {
                    if (chownErOk(er)) er = null;
                    if (cb) cb.apply(this, arguments);
                });
            };
        }
        function chmodFixSync(orig) {
            if (!orig) return orig;
            return function(target, mode) {
                try {
                    return orig.call(fs, target, mode);
                } catch (er) {
                    if (!chownErOk(er)) throw er;
                }
            };
        }
        function chownFix(orig) {
            if (!orig) return orig;
            return function(target, uid, gid, cb) {
                return orig.call(fs, target, uid, gid, function(er) {
                    if (chownErOk(er)) er = null;
                    if (cb) cb.apply(this, arguments);
                });
            };
        }
        function chownFixSync(orig) {
            if (!orig) return orig;
            return function(target, uid, gid) {
                try {
                    return orig.call(fs, target, uid, gid);
                } catch (er) {
                    if (!chownErOk(er)) throw er;
                }
            };
        }
        function statFix(orig) {
            if (!orig) return orig;
            return function(target, options, cb) {
                if (typeof options === 'function') {
                    cb = options;
                    options = null;
                }
                function callback(er, stats) {
                    if (stats) {
                        if (stats.uid < 0) stats.uid += 0x100000000;
                        if (stats.gid < 0) stats.gid += 0x100000000;
                    }
                    if (cb) cb.apply(this, arguments);
                }
                return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
            };
        }
        function statFixSync(orig) {
            if (!orig) return orig;
            return function(target, options) {
                var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
                if (stats) {
                    if (stats.uid < 0) stats.uid += 0x100000000;
                    if (stats.gid < 0) stats.gid += 0x100000000;
                }
                return stats;
            };
        }
        function chownErOk(er) {
            if (!er) return true;
            if (er.code === "ENOSYS") return true;
            var nonroot = !process.getuid || process.getuid() !== 0;
            if (nonroot) {
                if (er.code === "EINVAL" || er.code === "EPERM") return true;
            }
            return false;
        }
    }
}
,
"1bc1ea69":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "joinCommand", ()=>joinCommand);
    module.o(exports, "getEscapedCommand", ()=>getEscapedCommand);
    module.o(exports, "parseCommand", ()=>parseCommand);
    module.o(exports, "parseTemplates", ()=>parseTemplates);
    var _f_node_buffer = farmRequire('node:buffer');
    var _f_node_child_process = farmRequire('node:child_process');
    const normalizeArgs = (file, args = [])=>{
        if (!Array.isArray(args)) {
            return [
                file
            ];
        }
        return [
            file,
            ...args
        ];
    };
    const NO_ESCAPE_REGEXP = /^[\w.-]+$/;
    const escapeArg = (arg)=>{
        if (typeof arg !== 'string' || NO_ESCAPE_REGEXP.test(arg)) {
            return arg;
        }
        return `"${arg.replaceAll('"', '\\"')}"`;
    };
    var joinCommand = (file, args)=>normalizeArgs(file, args).join(' ');
    var getEscapedCommand = (file, args)=>normalizeArgs(file, args).map((arg)=>escapeArg(arg)).join(' ');
    const SPACES_REGEXP = / +/g;
    var parseCommand = (command)=>{
        const tokens = [];
        for (const token of command.trim().split(SPACES_REGEXP)){
            const previousToken = tokens.at(-1);
            if (previousToken && previousToken.endsWith('\\')) {
                tokens[tokens.length - 1] = `${previousToken.slice(0, -1)} ${token}`;
            } else {
                tokens.push(token);
            }
        }
        return tokens;
    };
    const parseExpression = (expression)=>{
        const typeOfExpression = typeof expression;
        if (typeOfExpression === 'string') {
            return expression;
        }
        if (typeOfExpression === 'number') {
            return String(expression);
        }
        if (typeOfExpression === 'object' && expression !== null && !(expression instanceof _f_node_child_process.ChildProcess) && 'stdout' in expression) {
            const typeOfStdout = typeof expression.stdout;
            if (typeOfStdout === 'string') {
                return expression.stdout;
            }
            if (_f_node_buffer.Buffer.isBuffer(expression.stdout)) {
                return expression.stdout.toString();
            }
            throw new TypeError(`Unexpected "${typeOfStdout}" stdout in template expression`);
        }
        throw new TypeError(`Unexpected "${typeOfExpression}" in template expression`);
    };
    const concatTokens = (tokens, nextTokens, isNew)=>isNew || tokens.length === 0 || nextTokens.length === 0 ? [
            ...tokens,
            ...nextTokens
        ] : [
            ...tokens.slice(0, -1),
            `${tokens.at(-1)}${nextTokens[0]}`,
            ...nextTokens.slice(1)
        ];
    const parseTemplate = ({ templates, expressions, tokens, index, template })=>{
        const templateString = template ?? templates.raw[index];
        const templateTokens = templateString.split(SPACES_REGEXP).filter(Boolean);
        const newTokens = concatTokens(tokens, templateTokens, templateString.startsWith(' '));
        if (index === expressions.length) {
            return newTokens;
        }
        const expression = expressions[index];
        const expressionTokens = Array.isArray(expression) ? expression.map((expression)=>parseExpression(expression)) : [
            parseExpression(expression)
        ];
        return concatTokens(newTokens, expressionTokens, templateString.endsWith(' '));
    };
    var parseTemplates = (templates, expressions)=>{
        let tokens = [];
        for (const [index, template] of templates.entries()){
            tokens = parseTemplate({
                templates,
                expressions,
                tokens,
                index,
                template
            });
        }
        return tokens;
    };
}
,
"22bacb69":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    var _f_buffer = farmRequire("128b79b8");
    module._(exports, "getStreamAsBuffer", _f_buffer);
    var _f_string = farmRequire("5260a5fd");
    module._(exports, "default", _f_string, "getStreamAsString");
}
,
"22ca6445":function  (module, exports, farmRequire, farmDynamicRequire) {
    function stringify(obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
        const EOF = finalEOL ? EOL : '';
        const str = JSON.stringify(obj, replacer, spaces);
        return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
        if (Buffer.isBuffer(content)) content = content.toString('utf8');
        return content.replace(/^\uFEFF/, '');
    }
    module.exports = {
        stringify,
        stripBom
    };
}
,
"2e2a91c0":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const metaCharsRegExp = /([()\][%!^"`<>&|;, *?])/g;
    function escapeCommand(arg) {
        arg = arg.replace(metaCharsRegExp, '^$1');
        return arg;
    }
    function escapeArgument(arg, doubleEscapeMetaChars) {
        arg = `${arg}`;
        arg = arg.replace(/(\\*)"/g, '$1$1\\"');
        arg = arg.replace(/(\\*)$/, '$1$1');
        arg = `"${arg}"`;
        arg = arg.replace(metaCharsRegExp, '^$1');
        if (doubleEscapeMetaChars) {
            arg = arg.replace(metaCharsRegExp, '^$1');
        }
        return arg;
    }
    module.exports.command = escapeCommand;
    module.exports.argument = escapeArgument;
}
,
"49576d3a":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs = globalThis.nodeRequire('fs', true);
    function checkPathExt(path, options) {
        var pathext = options.pathExt !== undefined ? options.pathExt : process.env.PATHEXT;
        if (!pathext) {
            return true;
        }
        pathext = pathext.split(';');
        if (pathext.indexOf('') !== -1) {
            return true;
        }
        for(var i = 0; i < pathext.length; i++){
            var p = pathext[i].toLowerCase();
            if (p && path.substr(-p.length).toLowerCase() === p) {
                return true;
            }
        }
        return false;
    }
    function checkStat(stat, path, options) {
        if (!stat.isSymbolicLink() && !stat.isFile()) {
            return false;
        }
        return checkPathExt(path, options);
    }
    function isexe(path, options, cb) {
        fs.stat(path, function(er, stat) {
            cb(er, er ? false : checkStat(stat, path, options));
        });
    }
    function sync(path, options) {
        return checkStat(fs.statSync(path), path, options);
    }
}
,
"49bd566f":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizeStdio", ()=>normalizeStdio);
    const aliases = [
        'stdin',
        'stdout',
        'stderr'
    ];
    const hasAlias = (options)=>aliases.some((alias)=>options[alias] !== undefined);
    var normalizeStdio = (options)=>{
        if (!options) {
            return;
        }
        const { stdio } = options;
        if (stdio === undefined) {
            return aliases.map((alias)=>options[alias]);
        }
        if (hasAlias(options)) {
            throw new Error(`It's not possible to provide \`stdio\` in combination with one of ${aliases.map((alias)=>`\`${alias}\``).join(', ')}`);
        }
        if (typeof stdio === 'string') {
            return stdio;
        }
        if (!Array.isArray(stdio)) {
            throw new TypeError(`Expected \`stdio\` to be of type \`string\` or \`Array\`, got \`${typeof stdio}\``);
        }
        const length = Math.max(stdio.length, aliases.length);
        return Array.from({
            length
        }, (value, index)=>stdio[index]);
    };
}
,
"4cf295d9":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const { PassThrough } = globalThis.nodeRequire('stream', true);
    module.exports = function() {
        var sources = [];
        var output = new PassThrough({
            objectMode: true
        });
        output.setMaxListeners(0);
        output.add = add;
        output.isEmpty = isEmpty;
        output.on('unpipe', remove);
        Array.prototype.slice.call(arguments).forEach(add);
        return output;
        function add(source) {
            if (Array.isArray(source)) {
                source.forEach(add);
                return this;
            }
            sources.push(source);
            source.once('end', remove.bind(null, source));
            source.once('error', output.emit.bind(output, 'error'));
            source.pipe(output, {
                end: false
            });
            return this;
        }
        function isEmpty() {
            return sources.length == 0;
        }
        function remove(source) {
            sources = sources.filter(function(it) {
                return it !== source;
            });
            if (!sources.length && output.readable) {
                output.end();
            }
        }
    };
}
,
"5260a5fd":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getStreamAsString", ()=>getStreamAsString);
    var _f_contents = farmRequire("65cacf70");
    var _f_utils = farmRequire("af163e73");
    async function getStreamAsString(stream, options) {
        return _f_contents.getStreamContents(stream, stringMethods, options);
    }
    const initString = ()=>({
            contents: '',
            textDecoder: new TextDecoder()
        });
    const useTextDecoder = (chunk, { textDecoder })=>textDecoder.decode(chunk, {
            stream: true
        });
    const addStringChunk = (convertedChunk, { contents })=>contents + convertedChunk;
    const truncateStringChunk = (convertedChunk, chunkSize)=>convertedChunk.slice(0, chunkSize);
    const getFinalStringChunk = ({ textDecoder })=>{
        const finalChunk = textDecoder.decode();
        return finalChunk === '' ? undefined : finalChunk;
    };
    const stringMethods = {
        init: initString,
        convertChunk: {
            string: _f_utils.identity,
            buffer: useTextDecoder,
            arrayBuffer: useTextDecoder,
            dataView: useTextDecoder,
            typedArray: useTextDecoder,
            others: _f_utils.throwObjectStream
        },
        getSize: _f_utils.getLengthProp,
        truncateChunk: truncateStringChunk,
        addChunk: addStringChunk,
        getFinalChunk: getFinalStringChunk,
        finalize: _f_utils.getContentsProp
    };
}
,
"56953f91":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const shebangRegex = farmRequire("ea5249cf", true);
    module.exports = (string = '')=>{
        const match = string.match(shebangRegex);
        if (!match) {
            return null;
        }
        const [path, argument] = match[0].replace(/#! ?/, '').split(' ');
        const binary = path.split('/').pop();
        if (binary === 'env') {
            return argument;
        }
        return argument ? `${binary} ${argument}` : binary;
    };
}
,
"5ad07f45":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const fs = globalThis.nodeRequire('fs', true);
    const shebangCommand = farmRequire("56953f91", true);
    function readShebang(command) {
        const size = 150;
        const buffer = Buffer.alloc(size);
        let fd;
        try {
            fd = fs.openSync(command, 'r');
            fs.readSync(fd, buffer, 0, size, 0);
            fs.closeSync(fd);
        } catch (e) {}
        return shebangCommand(buffer.toString());
    }
    module.exports = readShebang;
}
,
"5ea68443":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "SIGNALS", ()=>SIGNALS);
    var SIGNALS = [
        {
            name: "SIGHUP",
            number: 1,
            action: "terminate",
            description: "Terminal closed",
            standard: "posix"
        },
        {
            name: "SIGINT",
            number: 2,
            action: "terminate",
            description: "User interruption with CTRL-C",
            standard: "ansi"
        },
        {
            name: "SIGQUIT",
            number: 3,
            action: "core",
            description: "User interruption with CTRL-\\",
            standard: "posix"
        },
        {
            name: "SIGILL",
            number: 4,
            action: "core",
            description: "Invalid machine instruction",
            standard: "ansi"
        },
        {
            name: "SIGTRAP",
            number: 5,
            action: "core",
            description: "Debugger breakpoint",
            standard: "posix"
        },
        {
            name: "SIGABRT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "ansi"
        },
        {
            name: "SIGIOT",
            number: 6,
            action: "core",
            description: "Aborted",
            standard: "bsd"
        },
        {
            name: "SIGBUS",
            number: 7,
            action: "core",
            description: "Bus error due to misaligned, non-existing address or paging error",
            standard: "bsd"
        },
        {
            name: "SIGEMT",
            number: 7,
            action: "terminate",
            description: "Command should be emulated but is not implemented",
            standard: "other"
        },
        {
            name: "SIGFPE",
            number: 8,
            action: "core",
            description: "Floating point arithmetic error",
            standard: "ansi"
        },
        {
            name: "SIGKILL",
            number: 9,
            action: "terminate",
            description: "Forced termination",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGUSR1",
            number: 10,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGSEGV",
            number: 11,
            action: "core",
            description: "Segmentation fault",
            standard: "ansi"
        },
        {
            name: "SIGUSR2",
            number: 12,
            action: "terminate",
            description: "Application-specific signal",
            standard: "posix"
        },
        {
            name: "SIGPIPE",
            number: 13,
            action: "terminate",
            description: "Broken pipe or socket",
            standard: "posix"
        },
        {
            name: "SIGALRM",
            number: 14,
            action: "terminate",
            description: "Timeout or timer",
            standard: "posix"
        },
        {
            name: "SIGTERM",
            number: 15,
            action: "terminate",
            description: "Termination",
            standard: "ansi"
        },
        {
            name: "SIGSTKFLT",
            number: 16,
            action: "terminate",
            description: "Stack is empty or overflowed",
            standard: "other"
        },
        {
            name: "SIGCHLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "posix"
        },
        {
            name: "SIGCLD",
            number: 17,
            action: "ignore",
            description: "Child process terminated, paused or unpaused",
            standard: "other"
        },
        {
            name: "SIGCONT",
            number: 18,
            action: "unpause",
            description: "Unpaused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGSTOP",
            number: 19,
            action: "pause",
            description: "Paused",
            standard: "posix",
            forced: true
        },
        {
            name: "SIGTSTP",
            number: 20,
            action: "pause",
            description: "Paused using CTRL-Z or \"suspend\"",
            standard: "posix"
        },
        {
            name: "SIGTTIN",
            number: 21,
            action: "pause",
            description: "Background process cannot read terminal input",
            standard: "posix"
        },
        {
            name: "SIGBREAK",
            number: 21,
            action: "terminate",
            description: "User interruption with CTRL-BREAK",
            standard: "other"
        },
        {
            name: "SIGTTOU",
            number: 22,
            action: "pause",
            description: "Background process cannot write to terminal output",
            standard: "posix"
        },
        {
            name: "SIGURG",
            number: 23,
            action: "ignore",
            description: "Socket received out-of-band data",
            standard: "bsd"
        },
        {
            name: "SIGXCPU",
            number: 24,
            action: "core",
            description: "Process timed out",
            standard: "bsd"
        },
        {
            name: "SIGXFSZ",
            number: 25,
            action: "core",
            description: "File too big",
            standard: "bsd"
        },
        {
            name: "SIGVTALRM",
            number: 26,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGPROF",
            number: 27,
            action: "terminate",
            description: "Timeout or timer",
            standard: "bsd"
        },
        {
            name: "SIGWINCH",
            number: 28,
            action: "ignore",
            description: "Terminal window size changed",
            standard: "bsd"
        },
        {
            name: "SIGIO",
            number: 29,
            action: "terminate",
            description: "I/O is available",
            standard: "other"
        },
        {
            name: "SIGPOLL",
            number: 29,
            action: "terminate",
            description: "Watched event",
            standard: "other"
        },
        {
            name: "SIGINFO",
            number: 29,
            action: "ignore",
            description: "Request for process information",
            standard: "other"
        },
        {
            name: "SIGPWR",
            number: 30,
            action: "terminate",
            description: "Device running out of power",
            standard: "systemv"
        },
        {
            name: "SIGSYS",
            number: 31,
            action: "core",
            description: "Invalid system call",
            standard: "other"
        },
        {
            name: "SIGUNUSED",
            number: 31,
            action: "terminate",
            description: "Invalid system call",
            standard: "other"
        }
    ];
}
,
"5f5d635b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "verboseDefault", ()=>verboseDefault);
    module.o(exports, "logCommand", ()=>logCommand);
    var _f_node_util = farmRequire('node:util');
    var _f_node_process = module.i(farmRequire('node:process'));
    var verboseDefault = _f_node_util.debuglog('execa').enabled;
    const padField = (field, padding)=>String(field).padStart(padding, '0');
    const getTimestamp = ()=>{
        const date = new Date();
        return `${padField(date.getHours(), 2)}:${padField(date.getMinutes(), 2)}:${padField(date.getSeconds(), 2)}.${padField(date.getMilliseconds(), 3)}`;
    };
    var logCommand = (escapedCommand, { verbose })=>{
        if (!verbose) {
            return;
        }
        module.f(_f_node_process).stderr.write(`[${getTimestamp()}] ${escapedCommand}\n`);
    };
}
,
"63f59b29":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "signalsByName", ()=>signalsByName);
    module.o(exports, "signalsByNumber", ()=>signalsByNumber);
    var _f_node_os = farmRequire("node:os");
    var _f_realtime = farmRequire("153226a7");
    var _f_signals = farmRequire("187e10b8");
    const getSignalsByName = ()=>{
        const signals = _f_signals.getSignals();
        return Object.fromEntries(signals.map(getSignalByName));
    };
    const getSignalByName = ({ name, number, description, supported, action, forced, standard })=>[
            name,
            {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        ];
    var signalsByName = getSignalsByName();
    const getSignalsByNumber = ()=>{
        const signals = _f_signals.getSignals();
        const length = _f_realtime.SIGRTMAX + 1;
        const signalsA = Array.from({
            length
        }, (value, number)=>getSignalByNumber(number, signals));
        return Object.assign({}, ...signalsA);
    };
    const getSignalByNumber = (number, signals)=>{
        const signal = findSignalByNumber(number, signals);
        if (signal === undefined) {
            return {};
        }
        const { name, description, supported, action, forced, standard } = signal;
        return {
            [number]: {
                name,
                number,
                description,
                supported,
                action,
                forced,
                standard
            }
        };
    };
    const findSignalByNumber = (number, signals)=>{
        const signal = signals.find(({ name })=>_f_node_os.constants.signals[name] === number);
        if (signal !== undefined) {
            return signal;
        }
        return signals.find((signalA)=>signalA.number === number);
    };
    var signalsByNumber = getSignalsByNumber();
}
,
"65cacf70":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getStreamContents", ()=>getStreamContents);
    module.o(exports, "MaxBufferError", ()=>MaxBufferError);
    var getStreamContents = async (stream, { init, convertChunk, getSize, truncateChunk, addChunk, getFinalChunk, finalize }, { maxBuffer = Number.POSITIVE_INFINITY } = {})=>{
        if (!isAsyncIterable(stream)) {
            throw new Error('The first argument must be a Readable, a ReadableStream, or an async iterable.');
        }
        const state = init();
        state.length = 0;
        try {
            for await (const chunk of stream){
                const chunkType = getChunkType(chunk);
                const convertedChunk = convertChunk[chunkType](chunk, state);
                appendChunk({
                    convertedChunk,
                    state,
                    getSize,
                    truncateChunk,
                    addChunk,
                    maxBuffer
                });
            }
            appendFinalChunk({
                state,
                convertChunk,
                getSize,
                truncateChunk,
                addChunk,
                getFinalChunk,
                maxBuffer
            });
            return finalize(state);
        } catch (error) {
            error.bufferedData = finalize(state);
            throw error;
        }
    };
    const appendFinalChunk = ({ state, getSize, truncateChunk, addChunk, getFinalChunk, maxBuffer })=>{
        const convertedChunk = getFinalChunk(state);
        if (convertedChunk !== undefined) {
            appendChunk({
                convertedChunk,
                state,
                getSize,
                truncateChunk,
                addChunk,
                maxBuffer
            });
        }
    };
    const appendChunk = ({ convertedChunk, state, getSize, truncateChunk, addChunk, maxBuffer })=>{
        const chunkSize = getSize(convertedChunk);
        const newLength = state.length + chunkSize;
        if (newLength <= maxBuffer) {
            addNewChunk(convertedChunk, state, addChunk, newLength);
            return;
        }
        const truncatedChunk = truncateChunk(convertedChunk, maxBuffer - state.length);
        if (truncatedChunk !== undefined) {
            addNewChunk(truncatedChunk, state, addChunk, maxBuffer);
        }
        throw new MaxBufferError();
    };
    const addNewChunk = (convertedChunk, state, addChunk, newLength)=>{
        state.contents = addChunk(convertedChunk, state, newLength);
        state.length = newLength;
    };
    const isAsyncIterable = (stream)=>typeof stream === 'object' && stream !== null && typeof stream[Symbol.asyncIterator] === 'function';
    const getChunkType = (chunk)=>{
        const typeOfChunk = typeof chunk;
        if (typeOfChunk === 'string') {
            return 'string';
        }
        if (typeOfChunk !== 'object' || chunk === null) {
            return 'others';
        }
        if (globalThis.Buffer?.isBuffer(chunk)) {
            return 'buffer';
        }
        const prototypeName = objectToString.call(chunk);
        if (prototypeName === '[object ArrayBuffer]') {
            return 'arrayBuffer';
        }
        if (prototypeName === '[object DataView]') {
            return 'dataView';
        }
        if (Number.isInteger(chunk.byteLength) && Number.isInteger(chunk.byteOffset) && objectToString.call(chunk.buffer) === '[object ArrayBuffer]') {
            return 'typedArray';
        }
        return 'others';
    };
    const { toString: objectToString } = Object.prototype;
    class MaxBufferError extends Error {
        name = 'MaxBufferError';
        constructor(){
            super('maxBuffer exceeded');
        }
    }
}
,
"712c2dd4":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    exports.fromCallback = function(fn) {
        return Object.defineProperty(function(...args) {
            if (typeof args[args.length - 1] === 'function') fn.apply(this, args);
            else {
                return new Promise((resolve, reject)=>{
                    args.push((err, res)=>err != null ? reject(err) : resolve(res));
                    fn.apply(this, args);
                });
            }
        }, 'name', {
            value: fn.name
        });
    };
    exports.fromPromise = function(fn) {
        return Object.defineProperty(function(...args) {
            const cb = args[args.length - 1];
            if (typeof cb !== 'function') return fn.apply(this, args);
            else {
                args.pop();
                fn.apply(this, args).then((r)=>cb(null, r), cb);
            }
        }, 'name', {
            value: fn.name
        });
    };
}
,
"71484603":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = balanced;
    function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);
        var r = range(a, b, str);
        return r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + a.length, r[1]),
            post: str.slice(r[1] + b.length)
        };
    }
    function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
            if (a === b) {
                return [
                    ai,
                    bi
                ];
            }
            begs = [];
            left = str.length;
            while(i >= 0 && !result){
                if (i == ai) {
                    begs.push(i);
                    ai = str.indexOf(a, i + 1);
                } else if (begs.length == 1) {
                    result = [
                        begs.pop(),
                        bi
                    ];
                } else {
                    beg = begs.pop();
                    if (beg < left) {
                        left = beg;
                        right = bi;
                    }
                    bi = str.indexOf(b, i + 1);
                }
                i = ai < bi && ai >= 0 ? ai : bi;
            }
            if (begs.length) {
                result = [
                    left,
                    right
                ];
            }
        }
        return result;
    }
}
,
"774c471c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
        return obj.__proto__;
    };
    function clone(obj) {
        if (obj === null || typeof obj !== 'object') return obj;
        if (obj instanceof Object) var copy = {
            __proto__: getPrototypeOf(obj)
        };
        else var copy = Object.create(null);
        Object.getOwnPropertyNames(obj).forEach(function(key) {
            Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
        });
        return copy;
    }
}
,
"776b08e2":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "addPipeMethods", ()=>addPipeMethods);
    var _f_node_fs = farmRequire('node:fs');
    var _f_node_child_process = farmRequire('node:child_process');
    var _f_is_stream = farmRequire("e7253e09");
    const isExecaChildProcess = (target)=>target instanceof _f_node_child_process.ChildProcess && typeof target.then === 'function';
    const pipeToTarget = (spawned, streamName, target)=>{
        if (typeof target === 'string') {
            spawned[streamName].pipe(_f_node_fs.createWriteStream(target));
            return spawned;
        }
        if (_f_is_stream.isWritableStream(target)) {
            spawned[streamName].pipe(target);
            return spawned;
        }
        if (!isExecaChildProcess(target)) {
            throw new TypeError('The second argument must be a string, a stream or an Execa child process.');
        }
        if (!_f_is_stream.isWritableStream(target.stdin)) {
            throw new TypeError('The target child process\'s stdin must be available.');
        }
        spawned[streamName].pipe(target.stdin);
        return target;
    };
    var addPipeMethods = (spawned)=>{
        if (spawned.stdout !== null) {
            spawned.pipeStdout = pipeToTarget.bind(undefined, spawned, 'stdout');
        }
        if (spawned.stderr !== null) {
            spawned.pipeStderr = pipeToTarget.bind(undefined, spawned, 'stderr');
        }
        if (spawned.all !== undefined) {
            spawned.pipeAll = pipeToTarget.bind(undefined, spawned, 'all');
        }
    };
}
,
"7a6c0c40":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "mergePromise", ()=>mergePromise);
    module.o(exports, "getSpawnedPromise", ()=>getSpawnedPromise);
    const nativePromisePrototype = (async ()=>{})().constructor.prototype;
    const descriptors = [
        'then',
        'catch',
        'finally'
    ].map((property)=>[
            property,
            Reflect.getOwnPropertyDescriptor(nativePromisePrototype, property)
        ]);
    var mergePromise = (spawned, promise)=>{
        for (const [property, descriptor] of descriptors){
            const value = typeof promise === 'function' ? (...args)=>Reflect.apply(descriptor.value, promise(), args) : descriptor.value.bind(promise);
            Reflect.defineProperty(spawned, property, {
                ...descriptor,
                value
            });
        }
    };
    var getSpawnedPromise = (spawned)=>new Promise((resolve, reject)=>{
            spawned.on('exit', (exitCode, signal)=>{
                resolve({
                    exitCode,
                    signal
                });
            });
            spawned.on('error', (error)=>{
                reject(error);
            });
            if (spawned.stdin) {
                spawned.stdin.on('error', (error)=>{
                    reject(error);
                });
            }
        });
}
,
"8871c848":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const cp = globalThis.nodeRequire('child_process', true);
    const parse = farmRequire("ec975e7c", true);
    const enoent = farmRequire("e0e571dc", true);
    function spawn(command, args, options) {
        const parsed = parse(command, args, options);
        const spawned = cp.spawn(parsed.command, parsed.args, parsed.options);
        enoent.hookChildProcess(spawned, parsed);
        return spawned;
    }
    function spawnSync(command, args, options) {
        const parsed = parse(command, args, options);
        const result = cp.spawnSync(parsed.command, parsed.args, parsed.options);
        result.error = result.error || enoent.verifyENOENTSync(result.status, parsed);
        return result;
    }
    module.exports = spawn;
    module.exports.spawn = spawn;
    module.exports.sync = spawnSync;
    module.exports._parse = parse;
    module.exports._enoent = enoent;
}
,
"8ab57d03":function  (module, exports, farmRequire, farmDynamicRequire) {
    var Stream = globalThis.nodeRequire('stream', true).Stream;
    module.exports = legacy;
    function legacy(fs) {
        return {
            ReadStream: ReadStream,
            WriteStream: WriteStream
        };
        function ReadStream(path, options) {
            if (!(this instanceof ReadStream)) return new ReadStream(path, options);
            Stream.call(this);
            var self = this;
            this.path = path;
            this.fd = null;
            this.readable = true;
            this.paused = false;
            this.flags = 'r';
            this.mode = 438;
            this.bufferSize = 64 * 1024;
            options = options || {};
            var keys = Object.keys(options);
            for(var index = 0, length = keys.length; index < length; index++){
                var key = keys[index];
                this[key] = options[key];
            }
            if (this.encoding) this.setEncoding(this.encoding);
            if (this.start !== undefined) {
                if ('number' !== typeof this.start) {
                    throw TypeError('start must be a Number');
                }
                if (this.end === undefined) {
                    this.end = Infinity;
                } else if ('number' !== typeof this.end) {
                    throw TypeError('end must be a Number');
                }
                if (this.start > this.end) {
                    throw new Error('start must be <= end');
                }
                this.pos = this.start;
            }
            if (this.fd !== null) {
                process.nextTick(function() {
                    self._read();
                });
                return;
            }
            fs.open(this.path, this.flags, this.mode, function(err, fd) {
                if (err) {
                    self.emit('error', err);
                    self.readable = false;
                    return;
                }
                self.fd = fd;
                self.emit('open', fd);
                self._read();
            });
        }
        function WriteStream(path, options) {
            if (!(this instanceof WriteStream)) return new WriteStream(path, options);
            Stream.call(this);
            this.path = path;
            this.fd = null;
            this.writable = true;
            this.flags = 'w';
            this.encoding = 'binary';
            this.mode = 438;
            this.bytesWritten = 0;
            options = options || {};
            var keys = Object.keys(options);
            for(var index = 0, length = keys.length; index < length; index++){
                var key = keys[index];
                this[key] = options[key];
            }
            if (this.start !== undefined) {
                if ('number' !== typeof this.start) {
                    throw TypeError('start must be a Number');
                }
                if (this.start < 0) {
                    throw new Error('start must be >= zero');
                }
                this.pos = this.start;
            }
            this.busy = false;
            this._queue = [];
            if (this.fd === null) {
                this._open = fs.open;
                this._queue.push([
                    this._open,
                    this.path,
                    this.flags,
                    this.mode,
                    undefined
                ]);
                this.flush();
            }
        }
    }
}
,
"97515120":function  (module, exports, farmRequire, farmDynamicRequire) {
    var balanced = farmRequire("71484603", true);
    module.exports = expandTop;
    var escSlash = '\0SLASH' + Math.random() + '\0';
    var escOpen = '\0OPEN' + Math.random() + '\0';
    var escClose = '\0CLOSE' + Math.random() + '\0';
    var escComma = '\0COMMA' + Math.random() + '\0';
    var escPeriod = '\0PERIOD' + Math.random() + '\0';
    function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
        return str.split('\\\\').join(escSlash).split('\\{').join(escOpen).split('\\}').join(escClose).split('\\,').join(escComma).split('\\.').join(escPeriod);
    }
    function unescapeBraces(str) {
        return str.split(escSlash).join('\\').split(escOpen).join('{').split(escClose).join('}').split(escComma).join(',').split(escPeriod).join('.');
    }
    function parseCommaParts(str) {
        if (!str) return [
            ''
        ];
        var parts = [];
        var m = balanced('{', '}', str);
        if (!m) return str.split(',');
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(',');
        p[p.length - 1] += '{' + body + '}';
        var postParts = parseCommaParts(post);
        if (post.length) {
            p[p.length - 1] += postParts.shift();
            p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
    }
    function expandTop(str) {
        if (!str) return [];
        if (str.substr(0, 2) === '{}') {
            str = '\\{\\}' + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
        return '{' + str + '}';
    }
    function isPadded(el) {
        return /^-?0\d/.test(el);
    }
    function lte(i, y) {
        return i <= y;
    }
    function gte(i, y) {
        return i >= y;
    }
    function expand(str, isTop) {
        var expansions = [];
        var m = balanced('{', '}', str);
        if (!m) return [
            str
        ];
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [
            ''
        ];
        if (/\$$/.test(m.pre)) {
            for(var k = 0; k < post.length; k++){
                var expansion = pre + '{' + m.body + '}' + post[k];
                expansions.push(expansion);
            }
        } else {
            var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
            var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
            var isSequence = isNumericSequence || isAlphaSequence;
            var isOptions = m.body.indexOf(',') >= 0;
            if (!isSequence && !isOptions) {
                if (m.post.match(/,.*\}/)) {
                    str = m.pre + '{' + m.body + escClose + m.post;
                    return expand(str);
                }
                return [
                    str
                ];
            }
            var n;
            if (isSequence) {
                n = m.body.split(/\.\./);
            } else {
                n = parseCommaParts(m.body);
                if (n.length === 1) {
                    n = expand(n[0], false).map(embrace);
                    if (n.length === 1) {
                        return post.map(function(p) {
                            return m.pre + n[0] + p;
                        });
                    }
                }
            }
            var N;
            if (isSequence) {
                var x = numeric(n[0]);
                var y = numeric(n[1]);
                var width = Math.max(n[0].length, n[1].length);
                var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
                var test = lte;
                var reverse = y < x;
                if (reverse) {
                    incr *= -1;
                    test = gte;
                }
                var pad = n.some(isPadded);
                N = [];
                for(var i = x; test(i, y); i += incr){
                    var c;
                    if (isAlphaSequence) {
                        c = String.fromCharCode(i);
                        if (c === '\\') c = '';
                    } else {
                        c = String(i);
                        if (pad) {
                            var need = width - c.length;
                            if (need > 0) {
                                var z = new Array(need + 1).join('0');
                                if (i < 0) c = '-' + z + c.slice(1);
                                else c = z + c;
                            }
                        }
                    }
                    N.push(c);
                }
            } else {
                N = [];
                for(var j = 0; j < n.length; j++){
                    N.push.apply(N, expand(n[j], false));
                }
            }
            for(var j = 0; j < N.length; j++){
                for(var k = 0; k < post.length; k++){
                    var expansion = pre + N[j] + post[k];
                    if (!isTop || isSequence || expansion) expansions.push(expansion);
                }
            }
        }
        return expansions;
    }
}
,
"9996a2b2":function  (module, exports, farmRequire, farmDynamicRequire) {
    const isWindows = process.platform === 'win32' || process.env.OSTYPE === 'cygwin' || process.env.OSTYPE === 'msys';
    const path = globalThis.nodeRequire('path', true);
    const COLON = isWindows ? ';' : ':';
    const isexe = farmRequire("14fd5962", true);
    const getNotFoundError = (cmd)=>Object.assign(new Error(`not found: ${cmd}`), {
            code: 'ENOENT'
        });
    const getPathInfo = (cmd, opt)=>{
        const colon = opt.colon || COLON;
        const pathEnv = cmd.match(/\//) || isWindows && cmd.match(/\\/) ? [
            ''
        ] : [
            ...isWindows ? [
                process.cwd()
            ] : [],
            ...(opt.path || process.env.PATH || '').split(colon)
        ];
        const pathExtExe = isWindows ? opt.pathExt || process.env.PATHEXT || '.EXE;.CMD;.BAT;.COM' : '';
        const pathExt = isWindows ? pathExtExe.split(colon) : [
            ''
        ];
        if (isWindows) {
            if (cmd.indexOf('.') !== -1 && pathExt[0] !== '') pathExt.unshift('');
        }
        return {
            pathEnv,
            pathExt,
            pathExtExe
        };
    };
    const which = (cmd, opt, cb)=>{
        if (typeof opt === 'function') {
            cb = opt;
            opt = {};
        }
        if (!opt) opt = {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        const step = (i)=>new Promise((resolve, reject)=>{
                if (i === pathEnv.length) return opt.all && found.length ? resolve(found) : reject(getNotFoundError(cmd));
                const ppRaw = pathEnv[i];
                const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
                const pCmd = path.join(pathPart, cmd);
                const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
                resolve(subStep(p, i, 0));
            });
        const subStep = (p, i, ii)=>new Promise((resolve, reject)=>{
                if (ii === pathExt.length) return resolve(step(i + 1));
                const ext = pathExt[ii];
                isexe(p + ext, {
                    pathExt: pathExtExe
                }, (er, is)=>{
                    if (!er && is) {
                        if (opt.all) found.push(p + ext);
                        else return resolve(p + ext);
                    }
                    return resolve(subStep(p, i, ii + 1));
                });
            });
        return cb ? step(0).then((res)=>cb(null, res), cb) : step(0);
    };
    const whichSync = (cmd, opt)=>{
        opt = opt || {};
        const { pathEnv, pathExt, pathExtExe } = getPathInfo(cmd, opt);
        const found = [];
        for(let i = 0; i < pathEnv.length; i++){
            const ppRaw = pathEnv[i];
            const pathPart = /^".*"$/.test(ppRaw) ? ppRaw.slice(1, -1) : ppRaw;
            const pCmd = path.join(pathPart, cmd);
            const p = !pathPart && /^\.[\\\/]/.test(cmd) ? cmd.slice(0, 2) + pCmd : pCmd;
            for(let j = 0; j < pathExt.length; j++){
                const cur = p + pathExt[j];
                try {
                    const is = isexe.sync(cur, {
                        pathExt: pathExtExe
                    });
                    if (is) {
                        if (opt.all) found.push(cur);
                        else return cur;
                    }
                } catch (ex) {}
            }
        }
        if (opt.all && found.length) return found;
        if (opt.nothrow) return null;
        throw getNotFoundError(cmd);
    };
    module.exports = which;
    which.sync = whichSync;
}
,
"a9681a9b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "spawnedKill", ()=>spawnedKill);
    module.o(exports, "spawnedCancel", ()=>spawnedCancel);
    module.o(exports, "setupTimeout", ()=>setupTimeout);
    module.o(exports, "validateTimeout", ()=>validateTimeout);
    module.o(exports, "setExitHandler", ()=>setExitHandler);
    var _f_node_os = module.i(farmRequire('node:os'));
    var _f_signal_exit = farmRequire("d9e2d344");
    const DEFAULT_FORCE_KILL_TIMEOUT = 1000 * 5;
    var spawnedKill = (kill, signal = 'SIGTERM', options = {})=>{
        const killResult = kill(signal);
        setKillTimeout(kill, signal, options, killResult);
        return killResult;
    };
    const setKillTimeout = (kill, signal, options, killResult)=>{
        if (!shouldForceKill(signal, options, killResult)) {
            return;
        }
        const timeout = getForceKillAfterTimeout(options);
        const t = setTimeout(()=>{
            kill('SIGKILL');
        }, timeout);
        if (t.unref) {
            t.unref();
        }
    };
    const shouldForceKill = (signal, { forceKillAfterTimeout }, killResult)=>isSigterm(signal) && forceKillAfterTimeout !== false && killResult;
    const isSigterm = (signal)=>signal === module.f(_f_node_os).constants.signals.SIGTERM || typeof signal === 'string' && signal.toUpperCase() === 'SIGTERM';
    const getForceKillAfterTimeout = ({ forceKillAfterTimeout = true })=>{
        if (forceKillAfterTimeout === true) {
            return DEFAULT_FORCE_KILL_TIMEOUT;
        }
        if (!Number.isFinite(forceKillAfterTimeout) || forceKillAfterTimeout < 0) {
            throw new TypeError(`Expected the \`forceKillAfterTimeout\` option to be a non-negative integer, got \`${forceKillAfterTimeout}\` (${typeof forceKillAfterTimeout})`);
        }
        return forceKillAfterTimeout;
    };
    var spawnedCancel = (spawned, context)=>{
        const killResult = spawned.kill();
        if (killResult) {
            context.isCanceled = true;
        }
    };
    const timeoutKill = (spawned, signal, reject)=>{
        spawned.kill(signal);
        reject(Object.assign(new Error('Timed out'), {
            timedOut: true,
            signal
        }));
    };
    var setupTimeout = (spawned, { timeout, killSignal = 'SIGTERM' }, spawnedPromise)=>{
        if (timeout === 0 || timeout === undefined) {
            return spawnedPromise;
        }
        let timeoutId;
        const timeoutPromise = new Promise((resolve, reject)=>{
            timeoutId = setTimeout(()=>{
                timeoutKill(spawned, killSignal, reject);
            }, timeout);
        });
        const safeSpawnedPromise = spawnedPromise.finally(()=>{
            clearTimeout(timeoutId);
        });
        return Promise.race([
            timeoutPromise,
            safeSpawnedPromise
        ]);
    };
    var validateTimeout = ({ timeout })=>{
        if (timeout !== undefined && (!Number.isFinite(timeout) || timeout < 0)) {
            throw new TypeError(`Expected the \`timeout\` option to be a non-negative integer, got \`${timeout}\` (${typeof timeout})`);
        }
    };
    var setExitHandler = async (spawned, { cleanup, detached }, timedPromise)=>{
        if (!cleanup || detached) {
            return timedPromise;
        }
        const removeExitHandler = _f_signal_exit.onExit(()=>{
            spawned.kill();
        });
        return timedPromise.finally(()=>{
            removeExitHandler();
        });
    };
}
,
"a96a11d7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "npmRunPath", ()=>npmRunPath);
    module.o(exports, "npmRunPathEnv", ()=>npmRunPathEnv);
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_url = farmRequire('node:url');
    var _f_path_key = module.i(farmRequire("e82dd834"));
    var npmRunPath = ({ cwd = module.f(_f_node_process).cwd(), path: pathOption = module.f(_f_node_process).env[module.f(_f_path_key)()], preferLocal = true, execPath = module.f(_f_node_process).execPath, addExecPath = true } = {})=>{
        const cwdString = cwd instanceof URL ? _f_node_url.fileURLToPath(cwd) : cwd;
        const cwdPath = module.f(_f_node_path).resolve(cwdString);
        const result = [];
        if (preferLocal) {
            applyPreferLocal(result, cwdPath);
        }
        if (addExecPath) {
            applyExecPath(result, execPath, cwdPath);
        }
        return [
            ...result,
            pathOption
        ].join(module.f(_f_node_path).delimiter);
    };
    const applyPreferLocal = (result, cwdPath)=>{
        let previous;
        while(previous !== cwdPath){
            result.push(module.f(_f_node_path).join(cwdPath, 'node_modules/.bin'));
            previous = cwdPath;
            cwdPath = module.f(_f_node_path).resolve(cwdPath, '..');
        }
    };
    const applyExecPath = (result, execPath, cwdPath)=>{
        const execPathString = execPath instanceof URL ? _f_node_url.fileURLToPath(execPath) : execPath;
        result.push(module.f(_f_node_path).resolve(cwdPath, execPathString, '..'));
    };
    var npmRunPathEnv = ({ env = module.f(_f_node_process).env, ...options } = {})=>{
        env = {
            ...env
        };
        const pathName = module.f(_f_path_key)({
            env
        });
        options.path = env[pathName];
        env[pathName] = npmRunPath(options);
        return env;
    };
}
,
"abb2baa0":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "getStreamAsArrayBuffer", ()=>getStreamAsArrayBuffer);
    var _f_contents = farmRequire("65cacf70");
    var _f_utils = farmRequire("af163e73");
    async function getStreamAsArrayBuffer(stream, options) {
        return _f_contents.getStreamContents(stream, arrayBufferMethods, options);
    }
    const initArrayBuffer = ()=>({
            contents: new ArrayBuffer(0)
        });
    const useTextEncoder = (chunk)=>textEncoder.encode(chunk);
    const textEncoder = new TextEncoder();
    const useUint8Array = (chunk)=>new Uint8Array(chunk);
    const useUint8ArrayWithOffset = (chunk)=>new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    const truncateArrayBufferChunk = (convertedChunk, chunkSize)=>convertedChunk.slice(0, chunkSize);
    const addArrayBufferChunk = (convertedChunk, { contents, length: previousLength }, length)=>{
        const newContents = hasArrayBufferResize() ? resizeArrayBuffer(contents, length) : resizeArrayBufferSlow(contents, length);
        new Uint8Array(newContents).set(convertedChunk, previousLength);
        return newContents;
    };
    const resizeArrayBufferSlow = (contents, length)=>{
        if (length <= contents.byteLength) {
            return contents;
        }
        const arrayBuffer = new ArrayBuffer(getNewContentsLength(length));
        new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
        return arrayBuffer;
    };
    const resizeArrayBuffer = (contents, length)=>{
        if (length <= contents.maxByteLength) {
            contents.resize(length);
            return contents;
        }
        const arrayBuffer = new ArrayBuffer(length, {
            maxByteLength: getNewContentsLength(length)
        });
        new Uint8Array(arrayBuffer).set(new Uint8Array(contents), 0);
        return arrayBuffer;
    };
    const getNewContentsLength = (length)=>SCALE_FACTOR ** Math.ceil(Math.log(length) / Math.log(SCALE_FACTOR));
    const SCALE_FACTOR = 2;
    const finalizeArrayBuffer = ({ contents, length })=>hasArrayBufferResize() ? contents : contents.slice(0, length);
    const hasArrayBufferResize = ()=>'resize' in ArrayBuffer.prototype;
    const arrayBufferMethods = {
        init: initArrayBuffer,
        convertChunk: {
            string: useTextEncoder,
            buffer: useUint8Array,
            arrayBuffer: useUint8Array,
            dataView: useUint8ArrayWithOffset,
            typedArray: useUint8ArrayWithOffset,
            others: _f_utils.throwObjectStream
        },
        getSize: _f_utils.getLengthProp,
        truncateChunk: truncateArrayBufferChunk,
        addChunk: addArrayBufferChunk,
        getFinalChunk: _f_utils.noop,
        finalize: finalizeArrayBuffer
    };
}
,
"af163e73":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "identity", ()=>identity);
    module.o(exports, "noop", ()=>noop);
    module.o(exports, "getContentsProp", ()=>getContentsProp);
    module.o(exports, "throwObjectStream", ()=>throwObjectStream);
    module.o(exports, "getLengthProp", ()=>getLengthProp);
    var identity = (value)=>value;
    var noop = ()=>undefined;
    var getContentsProp = ({ contents })=>contents;
    var throwObjectStream = (chunk)=>{
        throw new Error(`Streams in object mode are not supported: ${String(chunk)}`);
    };
    var getLengthProp = (convertedChunk)=>convertedChunk.length;
}
,
"ba69a156":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const pathKey = (options = {})=>{
        const environment = options.env || process.env;
        const platform = options.platform || process.platform;
        if (platform !== 'win32') {
            return 'PATH';
        }
        return Object.keys(environment).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';
    };
    module.exports = pathKey;
    module.exports.default = pathKey;
}
,
"c0c38fad":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "execa", ()=>execa);
    module.o(exports, "execaSync", ()=>execaSync);
    module.o(exports, "$", ()=>$);
    module.o(exports, "execaCommand", ()=>execaCommand);
    var _f_node_buffer = farmRequire('node:buffer');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_node_child_process = module.i(farmRequire('node:child_process'));
    var _f_node_process = module.i(farmRequire('node:process'));
    var _f_cross_spawn = module.i(farmRequire("8871c848"));
    var _f_strip_final_newline = module.i(farmRequire("14cbc7d0"));
    var _f_npm_run_path = farmRequire("a96a11d7");
    var _f_onetime = module.i(farmRequire("0db3db94"));
    var _f_error = farmRequire("07218eb7");
    var _f_stdio = farmRequire("49bd566f");
    var _f_kill = farmRequire("a9681a9b");
    var _f_pipe = farmRequire("776b08e2");
    var _f_stream = farmRequire("f938ffa4");
    var _f_promise = farmRequire("7a6c0c40");
    var _f_command = farmRequire("1bc1ea69");
    var _f_verbose = farmRequire("5f5d635b");
    const DEFAULT_MAX_BUFFER = 1000 * 1000 * 100;
    const getEnv = ({ env: envOption, extendEnv, preferLocal, localDir, execPath })=>{
        const env = extendEnv ? {
            ...module.f(_f_node_process).env,
            ...envOption
        } : envOption;
        if (preferLocal) {
            return _f_npm_run_path.npmRunPathEnv({
                env,
                cwd: localDir,
                execPath
            });
        }
        return env;
    };
    const handleArguments = (file, args, options = {})=>{
        const parsed = module.f(_f_cross_spawn)._parse(file, args, options);
        file = parsed.command;
        args = parsed.args;
        options = parsed.options;
        options = {
            maxBuffer: DEFAULT_MAX_BUFFER,
            buffer: true,
            stripFinalNewline: true,
            extendEnv: true,
            preferLocal: false,
            localDir: options.cwd || module.f(_f_node_process).cwd(),
            execPath: module.f(_f_node_process).execPath,
            encoding: 'utf8',
            reject: true,
            cleanup: true,
            all: false,
            windowsHide: true,
            verbose: _f_verbose.verboseDefault,
            ...options
        };
        options.env = getEnv(options);
        options.stdio = _f_stdio.normalizeStdio(options);
        if (module.f(_f_node_process).platform === 'win32' && module.f(_f_node_path).basename(file, '.exe') === 'cmd') {
            args.unshift('/q');
        }
        return {
            file,
            args,
            options,
            parsed
        };
    };
    const handleOutput = (options, value, error)=>{
        if (typeof value !== 'string' && !_f_node_buffer.Buffer.isBuffer(value)) {
            return error === undefined ? undefined : '';
        }
        if (options.stripFinalNewline) {
            return module.f(_f_strip_final_newline)(value);
        }
        return value;
    };
    function execa(file, args, options) {
        const parsed = handleArguments(file, args, options);
        const command = _f_command.joinCommand(file, args);
        const escapedCommand = _f_command.getEscapedCommand(file, args);
        _f_verbose.logCommand(escapedCommand, parsed.options);
        _f_kill.validateTimeout(parsed.options);
        let spawned;
        try {
            spawned = module.f(_f_node_child_process).spawn(parsed.file, parsed.args, parsed.options);
        } catch (error) {
            const dummySpawned = new (module.f(_f_node_child_process)).ChildProcess();
            const errorPromise = Promise.reject(_f_error.makeError({
                error,
                stdout: '',
                stderr: '',
                all: '',
                command,
                escapedCommand,
                parsed,
                timedOut: false,
                isCanceled: false,
                killed: false
            }));
            _f_promise.mergePromise(dummySpawned, errorPromise);
            return dummySpawned;
        }
        const spawnedPromise = _f_promise.getSpawnedPromise(spawned);
        const timedPromise = _f_kill.setupTimeout(spawned, parsed.options, spawnedPromise);
        const processDone = _f_kill.setExitHandler(spawned, parsed.options, timedPromise);
        const context = {
            isCanceled: false
        };
        spawned.kill = _f_kill.spawnedKill.bind(null, spawned.kill.bind(spawned));
        spawned.cancel = _f_kill.spawnedCancel.bind(null, spawned, context);
        const handlePromise = async ()=>{
            const [{ error, exitCode, signal, timedOut }, stdoutResult, stderrResult, allResult] = await _f_stream.getSpawnedResult(spawned, parsed.options, processDone);
            const stdout = handleOutput(parsed.options, stdoutResult);
            const stderr = handleOutput(parsed.options, stderrResult);
            const all = handleOutput(parsed.options, allResult);
            if (error || exitCode !== 0 || signal !== null) {
                const returnedError = _f_error.makeError({
                    error,
                    exitCode,
                    signal,
                    stdout,
                    stderr,
                    all,
                    command,
                    escapedCommand,
                    parsed,
                    timedOut,
                    isCanceled: context.isCanceled || (parsed.options.signal ? parsed.options.signal.aborted : false),
                    killed: spawned.killed
                });
                if (!parsed.options.reject) {
                    return returnedError;
                }
                throw returnedError;
            }
            return {
                command,
                escapedCommand,
                exitCode: 0,
                stdout,
                stderr,
                all,
                failed: false,
                timedOut: false,
                isCanceled: false,
                killed: false
            };
        };
        const handlePromiseOnce = module.f(_f_onetime)(handlePromise);
        _f_stream.handleInput(spawned, parsed.options);
        spawned.all = _f_stream.makeAllStream(spawned, parsed.options);
        _f_pipe.addPipeMethods(spawned);
        _f_promise.mergePromise(spawned, handlePromiseOnce);
        return spawned;
    }
    function execaSync(file, args, options) {
        const parsed = handleArguments(file, args, options);
        const command = _f_command.joinCommand(file, args);
        const escapedCommand = _f_command.getEscapedCommand(file, args);
        _f_verbose.logCommand(escapedCommand, parsed.options);
        const input = _f_stream.handleInputSync(parsed.options);
        let result;
        try {
            result = module.f(_f_node_child_process).spawnSync(parsed.file, parsed.args, {
                ...parsed.options,
                input
            });
        } catch (error) {
            throw _f_error.makeError({
                error,
                stdout: '',
                stderr: '',
                all: '',
                command,
                escapedCommand,
                parsed,
                timedOut: false,
                isCanceled: false,
                killed: false
            });
        }
        const stdout = handleOutput(parsed.options, result.stdout, result.error);
        const stderr = handleOutput(parsed.options, result.stderr, result.error);
        if (result.error || result.status !== 0 || result.signal !== null) {
            const error = _f_error.makeError({
                stdout,
                stderr,
                error: result.error,
                signal: result.signal,
                exitCode: result.status,
                command,
                escapedCommand,
                parsed,
                timedOut: result.error && result.error.code === 'ETIMEDOUT',
                isCanceled: false,
                killed: result.signal !== null
            });
            if (!parsed.options.reject) {
                return error;
            }
            throw error;
        }
        return {
            command,
            escapedCommand,
            exitCode: 0,
            stdout,
            stderr,
            failed: false,
            timedOut: false,
            isCanceled: false,
            killed: false
        };
    }
    const normalizeScriptStdin = ({ input, inputFile, stdio })=>input === undefined && inputFile === undefined && stdio === undefined ? {
            stdin: 'inherit'
        } : {};
    const normalizeScriptOptions = (options = {})=>({
            preferLocal: true,
            ...normalizeScriptStdin(options),
            ...options
        });
    function create$(options) {
        function $(templatesOrOptions, ...expressions) {
            if (!Array.isArray(templatesOrOptions)) {
                return create$({
                    ...options,
                    ...templatesOrOptions
                });
            }
            const [file, ...args] = _f_command.parseTemplates(templatesOrOptions, expressions);
            return execa(file, args, normalizeScriptOptions(options));
        }
        $.sync = (templates, ...expressions)=>{
            if (!Array.isArray(templates)) {
                throw new TypeError('Please use $(options).sync`command` instead of $.sync(options)`command`.');
            }
            const [file, ...args] = _f_command.parseTemplates(templates, expressions);
            return execaSync(file, args, normalizeScriptOptions(options));
        };
        return $;
    }
    var $ = create$();
    function execaCommand(command, options) {
        const [file, ...args] = _f_command.parseCommand(command);
        return execa(file, args, options);
    }
}
,
"c9805378":function  (module, exports, farmRequire, farmDynamicRequire) {
    module.exports = isexe;
    isexe.sync = sync;
    var fs = globalThis.nodeRequire('fs', true);
    function isexe(path, options, cb) {
        fs.stat(path, function(er, stat) {
            cb(er, er ? false : checkStat(stat, options));
        });
    }
    function sync(path, options) {
        return checkStat(fs.statSync(path), options);
    }
    function checkStat(stat, options) {
        return stat.isFile() && checkMode(stat, options);
    }
    function checkMode(stat, options) {
        var mod = stat.mode;
        var uid = stat.uid;
        var gid = stat.gid;
        var myUid = options.uid !== undefined ? options.uid : process.getuid && process.getuid();
        var myGid = options.gid !== undefined ? options.gid : process.getgid && process.getgid();
        var u = parseInt('100', 8);
        var g = parseInt('010', 8);
        var o = parseInt('001', 8);
        var ug = u | g;
        var ret = mod & o || mod & g && gid === myGid || mod & u && uid === myUid || mod & ug && myUid === 0;
        return ret;
    }
}
,
"e0e571dc":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const isWin = process.platform === 'win32';
    function notFoundError(original, syscall) {
        return Object.assign(new Error(`${syscall} ${original.command} ENOENT`), {
            code: 'ENOENT',
            errno: 'ENOENT',
            syscall: `${syscall} ${original.command}`,
            path: original.command,
            spawnargs: original.args
        });
    }
    function hookChildProcess(cp, parsed) {
        if (!isWin) {
            return;
        }
        const originalEmit = cp.emit;
        cp.emit = function(name, arg1) {
            if (name === 'exit') {
                const err = verifyENOENT(arg1, parsed, 'spawn');
                if (err) {
                    return originalEmit.call(cp, 'error', err);
                }
            }
            return originalEmit.apply(cp, arguments);
        };
    }
    function verifyENOENT(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, 'spawn');
        }
        return null;
    }
    function verifyENOENTSync(status, parsed) {
        if (isWin && status === 1 && !parsed.file) {
            return notFoundError(parsed.original, 'spawnSync');
        }
        return null;
    }
    module.exports = {
        hookChildProcess,
        verifyENOENT,
        verifyENOENTSync,
        notFoundError
    };
}
,
"e6b6986c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = globalThis.nodeRequire('path', true);
    const which = farmRequire("9996a2b2", true);
    const getPathKey = farmRequire("ba69a156", true);
    function resolveCommandAttempt(parsed, withoutPathExt) {
        const env = parsed.options.env || process.env;
        const cwd = process.cwd();
        const hasCustomCwd = parsed.options.cwd != null;
        const shouldSwitchCwd = hasCustomCwd && process.chdir !== undefined && !process.chdir.disabled;
        if (shouldSwitchCwd) {
            try {
                process.chdir(parsed.options.cwd);
            } catch (err) {}
        }
        let resolved;
        try {
            resolved = which.sync(parsed.command, {
                path: env[getPathKey({
                    env
                })],
                pathExt: withoutPathExt ? path.delimiter : undefined
            });
        } catch (e) {} finally{
            if (shouldSwitchCwd) {
                process.chdir(cwd);
            }
        }
        if (resolved) {
            resolved = path.resolve(hasCustomCwd ? parsed.options.cwd : '', resolved);
        }
        return resolved;
    }
    function resolveCommand(parsed) {
        return resolveCommandAttempt(parsed) || resolveCommandAttempt(parsed, true);
    }
    module.exports = resolveCommand;
}
,
"e7253e09":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "isStream", ()=>isStream);
    module.o(exports, "isWritableStream", ()=>isWritableStream);
    function isStream(stream) {
        return stream !== null && typeof stream === 'object' && typeof stream.pipe === 'function';
    }
    function isWritableStream(stream) {
        return isStream(stream) && stream.writable !== false && typeof stream._write === 'function' && typeof stream._writableState === 'object';
    }
}
,
"e82dd834":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>pathKey);
    function pathKey(options = {}) {
        const { env = process.env, platform = process.platform } = options;
        if (platform !== 'win32') {
            return 'PATH';
        }
        return Object.keys(env).reverse().find((key)=>key.toUpperCase() === 'PATH') || 'Path';
    }
}
,
"ea5249cf":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    module.exports = /^#!(.*)/;
}
,
"ec975e7c":function  (module, exports, farmRequire, farmDynamicRequire) {
    'use strict';
    const path = globalThis.nodeRequire('path', true);
    const resolveCommand = farmRequire("e6b6986c", true);
    const escape = farmRequire("2e2a91c0", true);
    const readShebang = farmRequire("5ad07f45", true);
    const isWin = process.platform === 'win32';
    const isExecutableRegExp = /\.(?:com|exe)$/i;
    const isCmdShimRegExp = /node_modules[\\/].bin[\\/][^\\/]+\.cmd$/i;
    function detectShebang(parsed) {
        parsed.file = resolveCommand(parsed);
        const shebang = parsed.file && readShebang(parsed.file);
        if (shebang) {
            parsed.args.unshift(parsed.file);
            parsed.command = shebang;
            return resolveCommand(parsed);
        }
        return parsed.file;
    }
    function parseNonShell(parsed) {
        if (!isWin) {
            return parsed;
        }
        const commandFile = detectShebang(parsed);
        const needsShell = !isExecutableRegExp.test(commandFile);
        if (parsed.options.forceShell || needsShell) {
            const needsDoubleEscapeMetaChars = isCmdShimRegExp.test(commandFile);
            parsed.command = path.normalize(parsed.command);
            parsed.command = escape.command(parsed.command);
            parsed.args = parsed.args.map((arg)=>escape.argument(arg, needsDoubleEscapeMetaChars));
            const shellCommand = [
                parsed.command
            ].concat(parsed.args).join(' ');
            parsed.args = [
                '/d',
                '/s',
                '/c',
                `"${shellCommand}"`
            ];
            parsed.command = process.env.comspec || 'cmd.exe';
            parsed.options.windowsVerbatimArguments = true;
        }
        return parsed;
    }
    function parse(command, args, options) {
        if (args && !Array.isArray(args)) {
            options = args;
            args = null;
        }
        args = args ? args.slice(0) : [];
        options = Object.assign({}, options);
        const parsed = {
            command,
            args,
            options,
            file: undefined,
            original: {
                command,
                args
            }
        };
        return options.shell ? parsed : parseNonShell(parsed);
    }
    module.exports = parse;
}
,
"f938ffa4":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "handleInputSync", ()=>handleInputSync);
    module.o(exports, "handleInput", ()=>handleInput);
    module.o(exports, "makeAllStream", ()=>makeAllStream);
    module.o(exports, "getSpawnedResult", ()=>getSpawnedResult);
    var _f_node_fs = farmRequire('node:fs');
    var _f_promises = farmRequire('node:timers/promises');
    var _f_is_stream = farmRequire("e7253e09");
    var _f_get_stream = module.w(farmRequire("22bacb69"));
    var _f_merge_stream = module.i(farmRequire("4cf295d9"));
    const validateInputOptions = (input)=>{
        if (input !== undefined) {
            throw new TypeError('The `input` and `inputFile` options cannot be both set.');
        }
    };
    const getInputSync = ({ input, inputFile })=>{
        if (typeof inputFile !== 'string') {
            return input;
        }
        validateInputOptions(input);
        return _f_node_fs.readFileSync(inputFile);
    };
    var handleInputSync = (options)=>{
        const input = getInputSync(options);
        if (_f_is_stream.isStream(input)) {
            throw new TypeError('The `input` option cannot be a stream in sync mode');
        }
        return input;
    };
    const getInput = ({ input, inputFile })=>{
        if (typeof inputFile !== 'string') {
            return input;
        }
        validateInputOptions(input);
        return _f_node_fs.createReadStream(inputFile);
    };
    var handleInput = (spawned, options)=>{
        const input = getInput(options);
        if (input === undefined) {
            return;
        }
        if (_f_is_stream.isStream(input)) {
            input.pipe(spawned.stdin);
        } else {
            spawned.stdin.end(input);
        }
    };
    var makeAllStream = (spawned, { all })=>{
        if (!all || !spawned.stdout && !spawned.stderr) {
            return;
        }
        const mixed = module.f(_f_merge_stream)();
        if (spawned.stdout) {
            mixed.add(spawned.stdout);
        }
        if (spawned.stderr) {
            mixed.add(spawned.stderr);
        }
        return mixed;
    };
    const getBufferedData = async (stream, streamPromise)=>{
        if (!stream || streamPromise === undefined) {
            return;
        }
        await _f_promises.setTimeout(0);
        stream.destroy();
        try {
            return await streamPromise;
        } catch (error) {
            return error.bufferedData;
        }
    };
    const getStreamPromise = (stream, { encoding, buffer, maxBuffer })=>{
        if (!stream || !buffer) {
            return;
        }
        if (encoding === 'utf8' || encoding === 'utf-8') {
            return module.f(_f_get_stream)(stream, {
                maxBuffer
            });
        }
        if (encoding === null || encoding === 'buffer') {
            return _f_get_stream.getStreamAsBuffer(stream, {
                maxBuffer
            });
        }
        return applyEncoding(stream, maxBuffer, encoding);
    };
    const applyEncoding = async (stream, maxBuffer, encoding)=>{
        const buffer = await _f_get_stream.getStreamAsBuffer(stream, {
            maxBuffer
        });
        return buffer.toString(encoding);
    };
    var getSpawnedResult = async ({ stdout, stderr, all }, { encoding, buffer, maxBuffer }, processDone)=>{
        const stdoutPromise = getStreamPromise(stdout, {
            encoding,
            buffer,
            maxBuffer
        });
        const stderrPromise = getStreamPromise(stderr, {
            encoding,
            buffer,
            maxBuffer
        });
        const allPromise = getStreamPromise(all, {
            encoding,
            buffer,
            maxBuffer: maxBuffer * 2
        });
        try {
            return await Promise.all([
                processDone,
                stdoutPromise,
                stderrPromise,
                allPromise
            ]);
        } catch (error) {
            return Promise.all([
                {
                    error,
                    signal: error.signal,
                    timedOut: error.timedOut
                },
                getBufferedData(stdout, stdoutPromise),
                getBufferedData(stderr, stderrPromise),
                getBufferedData(all, allPromise)
            ]);
        }
    };
}
,
"ffc819a8":function  (module, exports, farmRequire, farmDynamicRequire) {
    var fs = globalThis.nodeRequire('fs', true);
    var polyfills = farmRequire("1aaeac37", true);
    var legacy = farmRequire("8ab57d03", true);
    var clone = farmRequire("774c471c", true);
    var util = globalThis.nodeRequire('util', true);
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
        gracefulQueue = Symbol.for('graceful-fs.queue');
        previousSymbol = Symbol.for('graceful-fs.previous');
    } else {
        gracefulQueue = '___graceful-fs.queue';
        previousSymbol = '___graceful-fs.previous';
    }
    function noop() {}
    function publishQueue(context, queue) {
        Object.defineProperty(context, gracefulQueue, {
            get: function() {
                return queue;
            }
        });
    }
    var debug = noop;
    if (util.debuglog) debug = util.debuglog('gfs4');
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) debug = function() {
        var m = util.format.apply(util, arguments);
        m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ');
        console.error(m);
    };
    if (!fs[gracefulQueue]) {
        var queue = global[gracefulQueue] || [];
        publishQueue(fs, queue);
        fs.close = function(fs$close) {
            function close(fd, cb) {
                return fs$close.call(fs, fd, function(err) {
                    if (!err) {
                        resetQueue();
                    }
                    if (typeof cb === 'function') cb.apply(this, arguments);
                });
            }
            Object.defineProperty(close, previousSymbol, {
                value: fs$close
            });
            return close;
        }(fs.close);
        fs.closeSync = function(fs$closeSync) {
            function closeSync(fd) {
                fs$closeSync.apply(fs, arguments);
                resetQueue();
            }
            Object.defineProperty(closeSync, previousSymbol, {
                value: fs$closeSync
            });
            return closeSync;
        }(fs.closeSync);
        if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
            process.on('exit', function() {
                debug(fs[gracefulQueue]);
                globalThis.nodeRequire('assert', true).equal(fs[gracefulQueue].length, 0);
            });
        }
    }
    if (!global[gracefulQueue]) {
        publishQueue(global, fs[gracefulQueue]);
    }
    module.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
        module.exports = patch(fs);
        fs.__patched = true;
    }
    function patch(fs) {
        polyfills(fs);
        fs.gracefulify = patch;
        fs.createReadStream = createReadStream;
        fs.createWriteStream = createWriteStream;
        var fs$readFile = fs.readFile;
        fs.readFile = readFile;
        function readFile(path, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            return go$readFile(path, options, cb);
            function go$readFile(path, options, cb, startTime) {
                return fs$readFile(path, options, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$readFile,
                        [
                            path,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$writeFile = fs.writeFile;
        fs.writeFile = writeFile;
        function writeFile(path, data, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            return go$writeFile(path, data, options, cb);
            function go$writeFile(path, data, options, cb, startTime) {
                return fs$writeFile(path, data, options, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$writeFile,
                        [
                            path,
                            data,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$appendFile = fs.appendFile;
        if (fs$appendFile) fs.appendFile = appendFile;
        function appendFile(path, data, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            return go$appendFile(path, data, options, cb);
            function go$appendFile(path, data, options, cb, startTime) {
                return fs$appendFile(path, data, options, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$appendFile,
                        [
                            path,
                            data,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$copyFile = fs.copyFile;
        if (fs$copyFile) fs.copyFile = copyFile;
        function copyFile(src, dest, flags, cb) {
            if (typeof flags === 'function') {
                cb = flags;
                flags = 0;
            }
            return go$copyFile(src, dest, flags, cb);
            function go$copyFile(src, dest, flags, cb, startTime) {
                return fs$copyFile(src, dest, flags, function(err) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$copyFile,
                        [
                            src,
                            dest,
                            flags,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        var fs$readdir = fs.readdir;
        fs.readdir = readdir;
        var noReaddirOptionVersions = /^v[0-5]\./;
        function readdir(path, options, cb) {
            if (typeof options === 'function') cb = options, options = null;
            var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir(path, options, cb, startTime) {
                return fs$readdir(path, fs$readdirCallback(path, options, cb, startTime));
            } : function go$readdir(path, options, cb, startTime) {
                return fs$readdir(path, options, fs$readdirCallback(path, options, cb, startTime));
            };
            return go$readdir(path, options, cb);
            function fs$readdirCallback(path, options, cb, startTime) {
                return function(err, files) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$readdir,
                        [
                            path,
                            options,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (files && files.sort) files.sort();
                        if (typeof cb === 'function') cb.call(this, err, files);
                    }
                };
            }
        }
        if (process.version.substr(0, 4) === 'v0.8') {
            var legStreams = legacy(fs);
            ReadStream = legStreams.ReadStream;
            WriteStream = legStreams.WriteStream;
        }
        var fs$ReadStream = fs.ReadStream;
        if (fs$ReadStream) {
            ReadStream.prototype = Object.create(fs$ReadStream.prototype);
            ReadStream.prototype.open = ReadStream$open;
        }
        var fs$WriteStream = fs.WriteStream;
        if (fs$WriteStream) {
            WriteStream.prototype = Object.create(fs$WriteStream.prototype);
            WriteStream.prototype.open = WriteStream$open;
        }
        Object.defineProperty(fs, 'ReadStream', {
            get: function() {
                return ReadStream;
            },
            set: function(val) {
                ReadStream = val;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(fs, 'WriteStream', {
            get: function() {
                return WriteStream;
            },
            set: function(val) {
                WriteStream = val;
            },
            enumerable: true,
            configurable: true
        });
        var FileReadStream = ReadStream;
        Object.defineProperty(fs, 'FileReadStream', {
            get: function() {
                return FileReadStream;
            },
            set: function(val) {
                FileReadStream = val;
            },
            enumerable: true,
            configurable: true
        });
        var FileWriteStream = WriteStream;
        Object.defineProperty(fs, 'FileWriteStream', {
            get: function() {
                return FileWriteStream;
            },
            set: function(val) {
                FileWriteStream = val;
            },
            enumerable: true,
            configurable: true
        });
        function ReadStream(path, options) {
            if (this instanceof ReadStream) return fs$ReadStream.apply(this, arguments), this;
            else return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
        }
        function ReadStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
                if (err) {
                    if (that.autoClose) that.destroy();
                    that.emit('error', err);
                } else {
                    that.fd = fd;
                    that.emit('open', fd);
                    that.read();
                }
            });
        }
        function WriteStream(path, options) {
            if (this instanceof WriteStream) return fs$WriteStream.apply(this, arguments), this;
            else return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
        }
        function WriteStream$open() {
            var that = this;
            open(that.path, that.flags, that.mode, function(err, fd) {
                if (err) {
                    that.destroy();
                    that.emit('error', err);
                } else {
                    that.fd = fd;
                    that.emit('open', fd);
                }
            });
        }
        function createReadStream(path, options) {
            return new fs.ReadStream(path, options);
        }
        function createWriteStream(path, options) {
            return new fs.WriteStream(path, options);
        }
        var fs$open = fs.open;
        fs.open = open;
        function open(path, flags, mode, cb) {
            if (typeof mode === 'function') cb = mode, mode = null;
            return go$open(path, flags, mode, cb);
            function go$open(path, flags, mode, cb, startTime) {
                return fs$open(path, flags, mode, function(err, fd) {
                    if (err && (err.code === 'EMFILE' || err.code === 'ENFILE')) enqueue([
                        go$open,
                        [
                            path,
                            flags,
                            mode,
                            cb
                        ],
                        err,
                        startTime || Date.now(),
                        Date.now()
                    ]);
                    else {
                        if (typeof cb === 'function') cb.apply(this, arguments);
                    }
                });
            }
        }
        return fs;
    }
    function enqueue(elem) {
        debug('ENQUEUE', elem[0].name, elem[1]);
        fs[gracefulQueue].push(elem);
        retry();
    }
    var retryTimer;
    function resetQueue() {
        var now = Date.now();
        for(var i = 0; i < fs[gracefulQueue].length; ++i){
            if (fs[gracefulQueue][i].length > 2) {
                fs[gracefulQueue][i][3] = now;
                fs[gracefulQueue][i][4] = now;
            }
        }
        retry();
    }
    function retry() {
        clearTimeout(retryTimer);
        retryTimer = undefined;
        if (fs[gracefulQueue].length === 0) return;
        var elem = fs[gracefulQueue].shift();
        var fn = elem[0];
        var args = elem[1];
        var err = elem[2];
        var startTime = elem[3];
        var lastTime = elem[4];
        if (startTime === undefined) {
            debug('RETRY', fn.name, args);
            fn.apply(null, args);
        } else if (Date.now() - startTime >= 60000) {
            debug('TIMEOUT', fn.name, args);
            var cb = args.pop();
            if (typeof cb === 'function') cb.call(null, err);
        } else {
            var sinceAttempt = Date.now() - lastTime;
            var sinceStart = Math.max(lastTime - startTime, 1);
            var desiredDelay = Math.min(sinceStart * 1.2, 100);
            if (sinceAttempt >= desiredDelay) {
                debug('RETRY', fn.name, args);
                fn.apply(null, args.concat([
                    startTime
                ]));
            } else {
                fs[gracefulQueue].push(elem);
            }
        }
        if (retryTimer === undefined) {
            retryTimer = setTimeout(retry, 0);
        }
    }
}
,});