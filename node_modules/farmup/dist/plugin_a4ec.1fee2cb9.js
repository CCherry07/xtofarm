import * as __farm_external_module__farmfe_core from "@farmfe/core";import * as __farm_external_module_node_events from "node:events";import * as __farm_external_module_node_path from "node:path";(globalThis || window || global)['897f3a29e35d6dec0be3b29e442ddaba'].__farm_module_system__.setExternalModules({"@farmfe/core": __farm_external_module__farmfe_core && __farm_external_module__farmfe_core.default && !__farm_external_module__farmfe_core.__esModule ? {...__farm_external_module__farmfe_core,__esModule:true} : {...__farm_external_module__farmfe_core},"node:events": __farm_external_module_node_events && __farm_external_module_node_events.default && !__farm_external_module_node_events.__esModule ? {...__farm_external_module_node_events,__esModule:true} : {...__farm_external_module_node_events},"node:path": __farm_external_module_node_path && __farm_external_module_node_path.default && !__farm_external_module_node_path.__esModule ? {...__farm_external_module_node_path,__esModule:true} : {...__farm_external_module_node_path}});(function(_){for(var r in _){_[r].__farm_resource_pot__='plugin_a4ec.js';(globalThis || window || global)['897f3a29e35d6dec0be3b29e442ddaba'].__farm_module_system__.register(r,_[r])}})({"08c3113d":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "tryFindEntryFromUserConfig", ()=>tryFindEntryFromUserConfig);
    module.o(exports, "tryFindFormatFromPackage", ()=>tryFindFormatFromPackage);
    module.o(exports, "pinOutputEntryFilename", ()=>pinOutputEntryFilename);
    var _f_fs_extra = farmRequire("b70b51f5");
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_options = farmRequire("c461562d");
    var _f_file = farmRequire("ea49351b");
    const findEntryKeyFromObject = (input)=>{
        return Object.keys(input)[0];
    };
    const maybeEntryPrefix = [
        'src'
    ];
    const maybeEntries = [
        'index.ts',
        'main.ts',
        'index.js',
        'main.js',
        'index.html',
        'main.html',
        'main.htm'
    ];
    async function findDefaultExistsEntry() {
        let entry = '';
        const prefixList = [
            '',
            ...maybeEntryPrefix
        ];
        for (const prefix of prefixList){
            for (const item of maybeEntries){
                const filename = module.f(_f_node_path).join(prefix, item);
                if (await _f_file.isExists(filename) && (await _f_fs_extra.stat(filename)).isFile()) {
                    entry = filename;
                    break;
                }
            }
        }
        return entry;
    }
    function normalizeCommonEntry(entries) {
        function parseSingleEntry(entry) {
            if (!entry) return;
            const result = entry.split(':');
            if (result.length === 1) {
                return result[0];
            }
            const [key, ...value] = result;
            const file = value.join(':');
            if (!key) {
                throw new Error(`"${entry}" key is empty`);
            }
            if (!file) {
                throw new Error(`"${entry}" mapping file is empty`);
            }
            return [
                key,
                file
            ];
        }
        const normalizedEntries = {};
        const map = {};
        const sameMap = new Set();
        for (const entry of entries ?? []){
            const result = parseSingleEntry(entry);
            if (!result) continue;
            const [key, value] = Array.isArray(result) ? result : [
                undefined,
                result
            ];
            if (sameMap.has(value)) {
                continue;
            }
            sameMap.add(value);
            const find_uniq_key = (key, suffix = '')=>{
                const newKey = (key ?? 'index') + suffix;
                if (map[newKey]) {
                    map[newKey]++;
                    return find_uniq_key(key, map[newKey].toString());
                }
                map[newKey] = 1;
                return newKey;
            };
            const uniq_key = find_uniq_key(key);
            normalizedEntries[uniq_key] = value;
        }
        return Object.keys(normalizedEntries).length ? normalizedEntries : undefined;
    }
    async function tryFindEntryFromUserConfig(logger, config, options) {
        const entriesFromOption = normalizeCommonEntry(options.entry);
        if (entriesFromOption) {
            return entriesFromOption;
        }
        let findEntryKey = findEntryKeyFromObject(config.compilation?.input ?? {});
        if (findEntryKey) return config.compilation?.input;
        let findEntry = null;
        findEntry = await findDefaultExistsEntry();
        findEntryKey = 'index';
        if (!findEntry) {
            logger.error('entry is not found, please check your entry file correct', {
                exit: true
            });
            process.exit(1);
        } else {
            logger.info(`automatic find and use this entry: "${findEntry}"`);
        }
        return {
            [findEntryKey]: findEntry
        };
    }
    const packageModuleValueMapFormat = {
        module: 'esm',
        commonjs: 'cjs'
    };
    async function tryFindFormatFromPackage(root) {
        const packageFilename = module.f(_f_node_path).join(root, 'package.json');
        if (await _f_file.isExists(packageFilename)) {
            try {
                const content = JSON.parse(await _f_fs_extra.readFile(packageFilename, 'utf-8'));
                return packageModuleValueMapFormat[content.type];
            } catch (error) {
                return undefined;
            }
        }
        return undefined;
    }
    const formatMapExt = {
        cjs: 'js',
        esm: 'mjs'
    };
    function pinOutputEntryFilename(options) {
        if (options.noExecute) return;
        const executeMode = options.execute.type;
        if (options.target?.startsWith('browser')) {
            return;
        }
        if ((executeMode === _f_options.ExecuteMode.Custom || executeMode === _f_options.ExecuteMode.Node) && !options.noExecute) {
            options.entry = Object.entries(options.entry).reduce((res, [key, val])=>{
                res[`${key}.${formatMapExt[options.format ?? 'cjs']}`] = val;
                return res;
            }, {});
            options.outputEntry = {
                name: '[entryName]'
            };
        }
    }
}
,
"2494b3b9":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "Executer", ()=>Executer);
    var _f_execa = farmRequire("c0c38fad");
    var _f_options = farmRequire("c461562d");
    var _f_async = farmRequire("bc95c87b");
    var _f_log = farmRequire("720cc66c");
    class Executer {
        option;
        logger;
        normalizedOption;
        child;
        constructor(option, logger, normalizedOption){
            this.option = option;
            this.logger = logger;
            this.normalizedOption = normalizedOption;
        }
        execute(path, name, logger = this.logger) {
            switch(this.option.type){
                case _f_options.ExecuteMode.Browser:
                    {
                        break;
                    }
                case _f_options.ExecuteMode.Node:
                    {
                        this._execute('node', name, [
                            path,
                            ...this.option.args
                        ], logger);
                        break;
                    }
                case _f_options.ExecuteMode.Custom:
                    {
                        this._execute(this.option.command, name, [
                            path,
                            ...this.option.args
                        ], logger);
                        break;
                    }
            }
        }
        async _execute(command, name, args, logger) {
            if (this.child) {
                await this.closeChild();
            }
            const child = _f_execa.execaCommand([
                command,
                ...args
            ].join(' '), {
                cwd: process.cwd(),
                stdio: 'pipe'
            });
            child.stdout?.on('data', (data)=>logger.debug(_f_log.trimEndLF(data.toString())));
            child.stderr?.on('data', (err)=>logger.error(err));
            this.child = child;
            process.on('beforeExit', this.closeChild);
            process.on('exit', this.closeChild);
            child.once('exit', (code)=>{
                this.logger.info(`"${name}" PID ${child.pid} ${!code ? 'done' : `exit ${code}`}`);
                this.child = undefined;
            });
        }
        async closeChild() {
            if (!this.child) {
                return;
            }
            const child = this.child;
            const exitPromise = new Promise((resolve)=>{
                child.once('exit', ()=>{
                    resolve();
                });
            });
            try {
                await this.terminateChild(child);
                await exitPromise;
            } finally{
                this.child = undefined;
            }
        }
        async terminateChild(child) {
            while(child && !child.killed){
                child.kill();
                await _f_async.delay(30);
            }
        }
    }
}
,
"53f13165":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "defineProperty", ()=>defineProperty);
    module.o(exports, "proxyCompilerFn", ()=>proxyCompilerFn);
    function defineProperty(obj, key, value) {
        const origin = obj[key];
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        Object.defineProperty(obj, key, {
            value,
            ...descriptor
        });
        return origin;
    }
    function proxyCompilerFn(compiler, fnName, callback) {
        const handler = (...args)=>{
            const r = origin.bind(compiler)(...args);
            if (r instanceof Promise) {
                r.then((res)=>callback({
                        args,
                        result: res
                    }));
            } else {
                callback({
                    args,
                    result: r
                });
            }
            return r;
        };
        const origin = defineProperty(compiler, fnName, handler);
        return origin;
    }
}
,
"720cc66c":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "trimEndLF", ()=>trimEndLF);
    var trimEndLF = (str)=>{
        if (str.endsWith('\n')) {
            return str.slice(0, -1);
        }
        return str;
    };
}
,
"83d9fcab":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "ProxyCompiler", ()=>ProxyCompiler);
    var _f_node_events = module.i(farmRequire('node:events'));
    var _f_util = farmRequire("53f13165");
    class ProxyCompiler {
        compiler;
        event = new (module.f(_f_node_events))();
        _preProxyFnList = [];
        alreadyProxyFnList = new Set();
        start(compiler) {
            const isRestart = !!this.compiler;
            this.compiler = compiler;
            if (this._preProxyFnList.length) {
                for (const fnName of this._preProxyFnList){
                    this.proxyCompiler(fnName);
                }
                this._preProxyFnList = [];
            }
            if (isRestart) {
                const proxyFnList = this.alreadyProxyFnList;
                this.alreadyProxyFnList = new Set();
                for (const fnName of proxyFnList){
                    this.proxyCompiler(fnName);
                }
            }
        }
        proxyCompiler(fnName) {
            if (!this.compiler) {
                this._preProxyFnList.push(fnName);
                return;
            }
            if (this.alreadyProxyFnList.has(fnName)) {
                return;
            }
            this.alreadyProxyFnList.add(fnName);
            _f_util.proxyCompilerFn(this.compiler, fnName, (...args)=>this.event.emit(fnName, ...args));
        }
        on(fnName, fn) {
            this.proxyCompiler(fnName);
            this.event.on(fnName.toString(), fn);
            return ()=>{
                this.event.off(fnName.toString(), fn);
            };
        }
        onWriteResourcesToDisk(handler) {
            return this.on('writeResourcesToDisk', (r)=>handler(...r.args));
        }
    }
}
,
"97b7a878":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "NormalizeOption", ()=>_f_normalize.NormalizeOption);
    module.o(exports, "Executer", ()=>_f_executer.Executer);
    module.o(exports, "default", ()=>autoExecute);
    var _f_core = farmRequire('@farmfe/core');
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_normalize = farmRequire("eec540b7");
    var _f_constant = farmRequire("fe6f5e17");
    var _f_executer = farmRequire("2494b3b9");
    var _f_proxyCompiler = farmRequire("83d9fcab");
    function autoExecute(options = {}, logger = _f_constant.logger) {
        const name = options.name ?? _f_constant.CLI_NAME;
        let outputDir = undefined;
        let executer = null;
        const normalizeOption = new _f_normalize.NormalizeOption(options, logger);
        const proxyCompiler = new _f_proxyCompiler.ProxyCompiler();
        proxyCompiler.onWriteResourcesToDisk(()=>{
            if (normalizeOption.options.noExecute) {
                return;
            }
            if (!outputDir) {
                logger.error('outputDir is not found');
                return;
            }
            if (!normalizeOption.options.outputEntry) {
                return;
            }
            const resourceOutputEntry = Object.keys(normalizeOption.options.entry)[0];
            if (!resourceOutputEntry) {
                logger.error('output entry is not found');
                return;
            }
            const executePath = module.f(_f_node_path).join(outputDir, resourceOutputEntry);
            if (!executer) {
                executer = new _f_executer.Executer(normalizeOption.options.execute, logger, normalizeOption.options);
            }
            const nameWithoutExt = module.f(_f_node_path).parse(resourceOutputEntry).name;
            executer.execute(executePath, nameWithoutExt, new _f_core.Logger({
                name: `${name}:${nameWithoutExt}`
            }));
        });
        return {
            name: `${name}:execute`,
            priority: Number.NEGATIVE_INFINITY,
            async config (config) {
                return await normalizeOption.config(config);
            },
            configResolved (config) {
                outputDir = config.compilation?.output?.path;
                const format = config.compilation?.output?.format || normalizeOption.options.format;
                const targetEnv = config.compilation?.output?.targetEnv || normalizeOption.options.target;
                const entry = Object.values(config.compilation?.input || normalizeOption.options.entry)[0];
                logger.debug(`[entry: ${entry}] [format: ${format}] [target: ${targetEnv}]`);
            },
            configureCompiler (c) {
                proxyCompiler.start(c);
                if (!c.config.config?.watch) {
                    return;
                }
                if (options.noWatch) {
                    return;
                }
                const entries = Object.values(c.config.config?.input ?? {});
                if (entries.length === 0) {
                    return;
                }
                for (const entry of entries){
                    c.addExtraWatchFile(entry, normalizeOption.options.watchFiles);
                }
            }
        };
    }
}
,
"a98420ec":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "default", ()=>autoExternal);
    var _f_constant = farmRequire("fe6f5e17");
    function autoExternal() {
        return {
            priority: Number.NEGATIVE_INFINITY,
            name: `${_f_constant.CLI_NAME}:AutoExternal`,
            resolve: {
                filters: {
                    sources: [
                        '.*'
                    ],
                    importers: [
                        '.*'
                    ]
                },
                async executor (param) {
                    _f_constant.logger.debug(`${param.source} not found, it to be set external`);
                    return {
                        resolvedPath: param.source,
                        external: true
                    };
                }
            }
        };
    }
}
,
"bc95c87b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "delay", ()=>delay);
    var delay = (ms)=>new Promise((resolve)=>setTimeout(resolve, ms));
}
,
"c461562d":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "ExecuteMode", ()=>ExecuteMode);
    var ExecuteMode;
    (function(ExecuteMode) {
        ExecuteMode[ExecuteMode["Custom"] = 1] = "Custom";
        ExecuteMode[ExecuteMode["Node"] = 2] = "Node";
        ExecuteMode[ExecuteMode["Browser"] = 3] = "Browser";
    })(ExecuteMode || (ExecuteMode = {}));
}
,
"ea49351b":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "isExists", ()=>isExists);
    var _f_fs_extra = farmRequire("b70b51f5");
    var isExists = async (filename)=>{
        try {
            await _f_fs_extra.stat(filename);
            return true;
        } catch  {
            return false;
        }
    };
}
,
"eec540b7":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "normalizedTargetEnv", ()=>normalizedTargetEnv);
    module.o(exports, "NormalizeOption", ()=>NormalizeOption);
    var _f_options = farmRequire("c461562d");
    var _f_find_entry = farmRequire("08c3113d");
    var _f_lodash_es = farmRequire("6f6ce6ec");
    var _f_node_path = module.i(farmRequire('node:path'));
    var _f_file = farmRequire("ea49351b");
    var _f_glob = farmRequire("0e8afd43");
    function normalizedMinify(config, commonOptions, options) {
        if (!_f_lodash_es.isUndefined(commonOptions.minify)) {
            const minify = config.compilation?.minify;
            if (typeof minify === 'boolean' || _f_lodash_es.isObject(minify) && minify !== null) {
                options.minify = commonOptions.minify;
            }
        }
    }
    const extensionMapExecutedMode = {
        mjs: _f_options.ExecuteMode.Node,
        js: _f_options.ExecuteMode.Node,
        ts: _f_options.ExecuteMode.Node,
        html: _f_options.ExecuteMode.Browser,
        htm: _f_options.ExecuteMode.Browser
    };
    function normalizedExecuted(commonOption, options) {
        if (commonOption.execute) {
            options.execute = {
                type: _f_options.ExecuteMode.Custom,
                command: commonOption.execute,
                args: commonOption.args ?? []
            };
            return;
        }
        const target = commonOption.target;
        if (target) {
            if (target.includes('browser')) {
                options.execute = {
                    type: _f_options.ExecuteMode.Browser,
                    args: commonOption.args ?? []
                };
            } else if (target.includes('node')) {
                options.execute = {
                    type: _f_options.ExecuteMode.Node,
                    args: commonOption.args ?? []
                };
            }
        } else {
            const entryFiles = Object.values(options.entry);
            let res;
            for (const item of entryFiles){
                const targetFromExt = extensionMapExecutedMode[module.f(_f_node_path).extname(item).slice(1)];
                if (!_f_lodash_es.isUndefined(targetFromExt)) {
                    res = targetFromExt;
                    break;
                }
            }
            if (_f_lodash_es.isUndefined(res)) {
                res = _f_options.ExecuteMode.Node;
            }
            options.execute = {
                type: res,
                args: commonOption.args ?? []
            };
        }
    }
    async function normalizedFormat(config, commonOptions, options) {
        if (commonOptions.format) {
            options.format = commonOptions.format;
        } else if (config.compilation?.output?.format) {
            options.format = config.compilation.output.format;
        } else {
            const formatFromPackage = await _f_find_entry.tryFindFormatFromPackage(commonOptions.root ?? process.cwd());
            if (formatFromPackage) {
                options.format = formatFromPackage;
            } else {
                options.format = 'cjs';
            }
        }
    }
    const invalidTargetEnv = [
        'browser',
        'node',
        'node16',
        'node-legacy',
        'node-next',
        'browser-legacy',
        'browser-es2015',
        'browser-es2017',
        'browser-esnext'
    ];
    const extMapTargetEnv = {
        mjs: 'node',
        js: 'node',
        ts: 'node',
        html: 'browser',
        htm: 'browser'
    };
    function normalizedTargetEnv(config, commonOptions, options, logger) {
        config.compilation?.output?.targetEnv;
        if (commonOptions.target) {
            if (!invalidTargetEnv.includes(commonOptions.target)) {
                logger.error(`target ${commonOptions.target}  is invalid`);
            }
            options.target = commonOptions.target;
        } else if (config.compilation?.output?.targetEnv) {
            options.target = config.compilation.output.targetEnv;
        } else {
            let targetFromInput;
            for (const entryFile of Object.values(options.entry)){
                const ext = module.f(_f_node_path).extname(entryFile).slice(1);
                if (extMapTargetEnv[ext]) {
                    targetFromInput = extMapTargetEnv[ext];
                    break;
                }
            }
            if (targetFromInput) {
                options.target = targetFromInput;
            }
        }
    }
    async function normalizeWatchFiles(commonOptions) {
        const watchFiles = commonOptions.watchFiles ?? [];
        const result = [];
        for (const file of watchFiles){
            if (await _f_file.isExists(file)) {
                result.push(file);
                continue;
            }
            const matchFiles = await _f_glob.glob(file);
            result.push(...matchFiles);
        }
        return result;
    }
    async function normalizedSimpleConfig(config, commonOptions, options, logger) {
        const inputs = await _f_find_entry.tryFindEntryFromUserConfig(logger, config, commonOptions);
        options.entry = inputs;
        config.compilation ??= {};
        normalizedMinify(config, commonOptions, options);
        await normalizedFormat(config, commonOptions, options);
        normalizedTargetEnv(config, commonOptions, options, logger);
        _f_lodash_es.merge(options, {
            ...commonOptions.mode || config.compilation?.mode ? {
                mode: commonOptions.mode || config.compilation?.mode
            } : {},
            ...!_f_lodash_es.isUndefined(commonOptions.sourcemap ?? config.compilation?.sourcemap) ? {
                sourcemap: commonOptions.sourcemap ?? config.compilation?.sourcemap
            } : {},
            ...commonOptions.format || config.compilation?.output?.format ? {
                format: commonOptions.format || config.compilation?.output?.format
            } : {},
            ...commonOptions.target || config.compilation?.output?.targetEnv ? {
                target: commonOptions.target || config.compilation?.output?.targetEnv
            } : {},
            ...commonOptions.autoExternal ? {
                autoExternal: !!commonOptions.autoExternal
            } : {},
            external: commonOptions.external,
            outputDir: commonOptions.outputDir ?? config.compilation.output?.path ?? './dist',
            noExecute: commonOptions.noExecute ?? false,
            noWatch: commonOptions.noWatch ?? true,
            watchFiles: await normalizeWatchFiles(commonOptions)
        });
        normalizedExecuted(commonOptions, options);
        _f_find_entry.pinOutputEntryFilename(options);
    }
    function withServerOrWatch(userConfig, resolvedOption) {
        switch(resolvedOption.execute.type){
            case _f_options.ExecuteMode.Custom:
                {
                    _f_lodash_es.merge(userConfig, {
                        compilation: {
                            watch: !resolvedOption.noWatch
                        },
                        server: undefined
                    });
                    break;
                }
            case _f_options.ExecuteMode.Browser:
                {
                    if (!userConfig.server) {
                        _f_lodash_es.merge(userConfig, {
                            server: {
                                port: 12306,
                                cors: true
                            }
                        });
                    }
                    break;
                }
            case _f_options.ExecuteMode.Node:
                {
                    if (!userConfig.server) {
                        _f_lodash_es.merge(userConfig, {
                            compilation: {
                                watch: !resolvedOption.noWatch
                            },
                            server: undefined
                        });
                    }
                    break;
                }
        }
        return userConfig;
    }
    class NormalizeOption {
        commonOption;
        logger;
        options;
        constructor(commonOption, logger){
            this.commonOption = commonOption;
            this.logger = logger;
            this.options = {
                entry: {},
                args: [],
                execute: {
                    type: _f_options.ExecuteMode.Node,
                    args: []
                },
                external: [],
                mode: 'development',
                autoExternal: false,
                noExecute: false,
                watchFiles: [],
                outputDir: './dist',
                sourcemap: undefined
            };
        }
        async config(config) {
            await normalizedSimpleConfig(config, this.commonOption, this.options, this.logger);
            return withServerOrWatch({
                compilation: {
                    input: this.options.entry,
                    output: {
                        ..._f_lodash_es.pick(this.options, [
                            'format',
                            'mode'
                        ]),
                        ...this.options.target ? {
                            targetEnv: this.options.target
                        } : {},
                        ...this.options.outputEntry ? {
                            entryFilename: this.options.outputEntry.name
                        } : {},
                        path: this.options.outputDir
                    },
                    ..._f_lodash_es.pick(this.options, 'minify', 'sourcemap', 'external')
                }
            }, this.options);
        }
        async normalizeByCommonOption() {
            await normalizedSimpleConfig({}, this.commonOption, this.options, this.logger);
        }
        static async fromCommonOption(commonOption, logger) {
            const option = new NormalizeOption(commonOption, logger);
            await option.normalizeByCommonOption();
            return option;
        }
        merge(options) {
            this.options = {
                ...this.options,
                ...options
            };
        }
    }
}
,
"fe6f5e17":function  (module, exports, farmRequire, farmDynamicRequire) {
    module._m(exports);
    module.o(exports, "CLI_NAME", ()=>CLI_NAME);
    module.o(exports, "logger", ()=>logger);
    var _f_core = farmRequire("@farmfe/core");
    var CLI_NAME = 'Farmup';
    var logger = new _f_core.Logger({
        name: CLI_NAME
    });
}
,});
//# sourceMappingURL=plugin_a4ec.1fee2cb9.js.map